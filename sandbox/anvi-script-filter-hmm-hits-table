#!/usr/bin/env python
# -*- coding: utf-8

"""
This script removes the hmm_hits table and replaces it with a filtered version. Filtering of hmm_hits
is done using query and/or target coverage
"""

import sys
import os
import pandas as pd

import anvio
import anvio.db as db
import anvio.utils as utils
import anvio.hmmops as hmmops
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths

with terminal.SuppressAllOutput():
    import anvio.data.hmm as hmm_data

from anvio.dbops import ContigsDatabase
from anvio.parsers import parser_modules
from anvio.tables.hmmhits import TablesForHMMHits
from anvio.errors import ConfigError, FilesNPathsError

__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2020, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['mschecht']
__provides__ = ["hmm-hits"]
__requires__ = ["contigs-db","hmm-source", "hmm-hits"]
__description__ = ("Filter weak HMM hits from a given contigs database using a domain hits table "
                   "reported by `anvi-run-hmms`.")

pp = terminal.pretty_print

class FilterHmmHitsTable(object):
    """A class to filter hmm_hits from domtblout from hmmsearch."""
    def __init__(self, args, quiet=False, run=terminal.Run(), progress=terminal.Progress()):
        self.args = args
        self.run = run
        self.progress = progress

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None

        self.contigs_db_path=A("contigs_db")
        self.domtblout=A("domain_hits_table")
        self.hmm_source=A("hmm_source")
        self.target_coverage=A("target_coverage")
        self.query_coverage=A("query_coverage")
        self.list_hmm_sources=A("list_hmm_sources")
        self.hmm_profile_dir=A("hmm_profile_dir")

        if self.list_hmm_sources:
            ContigsDatabase(self.contigs_db_path).list_available_hmm_sources()
            sys.exit()

        # Grab HMM sources from internal or external HMMs
        if self.hmm_profile_dir:
            self.sources = utils.get_HMM_sources_dictionary([args.hmm_profile_dir])
        else:
            self.sources = hmm_data.sources

    def sanity_checks(self):
        """Sanity checks for program inputs."""

        filesnpaths.is_file_exists(self.contigs_db_path)
        self.run.info("Database Path", self.contigs_db_path)

        filesnpaths.is_file_exists(self.domtblout)
        self.run.info("Domtblout Path", self.domtblout)

        if not self.hmm_source:
            raise ConfigError("Please provide a hmm-source :)")

        info_table = hmmops.SequencesForHMMHits(self.contigs_db_path).hmm_hits_info

        if self.hmm_source not in info_table:
            raise ConfigError(f"Whoa there, the HMM source you provided, '{self.hmm_source}', is not in your contigsDB: "
                              f"{self.contigs_db_path}. Maybe you misspelled it? Maybe you never added it to your contigsDB??"
                              f"Please use --list-hmm-sources to see which HMM sources you have available. If you don't see the HMMs you "
                              f"need then try re-running anvi-run-hmms and make sure to specify your HMM source of interest.")

        target = self.sources[self.hmm_source]['target'].split(':')

        if target[0] != 'AA':
            raise ConfigError(f"The hmm-source {self.hmm_source} is not for amino acid sequences. "
                              f"anvi-script-filter-hmm-hit-table currently can only work with hmm-sources "
                              f"from protein sequences.")


    def process(self):
        """Method to run the functions of this program"""

        self.sanity_checks()

        self.import_domtblout()

        # file_path_csv
        filtered_domtblout_path = self.filter_domtblout()

        search_results_dict = self.parse_domtblout(filtered_domtblout_path)

        self.append_search_results_dict_to_hmm_tables(search_results_dict = search_results_dict)

        # remove the tmp file
        if anvio.DEBUG:
            self.run.info("Filtered domtblout file", filtered_domtblout_path)
        elif not anvio.DEBUG:
            os.remove(filtered_domtblout_path)


    def import_domtblout(self):
        """Import the domtblout file from hmmsearch then calculate query and target coverage"""
        # hmmsearch results so the queries are the hmm models and the targets are the ORFs
        col_info = [
            ('gene_callers_id',  int),   # target name
            ('target_accession', str),   # target accession
            ('gene_length',      int),   # tlen
            ('hmm_name',         str),   # query name
            ('hmm_id',           str),   # accession
            ('hmm_length',       int),   # qlen
            ('evalue',           float), # E-value (full sequence)
            ('bitscore',         float), # score (full sequence)
            ('bias',             float), # bias (full sequence)
            ('match_num',        int),   # # (this domain)
            ('num_matches',      int),   # of (this domain)
            ('dom_c_evalue',     float), # c-Evalue (this domain)
            ('dom_i_evalue',     float), # i-Evalue (this domain)
            ('dom_bitscore',     str),   # score (this domain)
            ('dom_bias',         float), # bias (this domain)
            ('hmm_start',        int),   # from (hmm coord)
            ('hmm_stop',         int),   # to (hmm coord)
            ('gene_start',       int),   # from (ali coord)
            ('gene_stop',        int),   # to (ali coord)
            ('env_to',           str),   # from (env coord)
            ('env_from',         str),   # to (env coord)
            ('mean_post_prob',   float), # acc
            ('description',      str),   # description of target
        ]

        try:
            colnames_coltypes_list = list(zip(*col_info))
            colnames_coltypes_dict = dict(zip(colnames_coltypes_list[0], colnames_coltypes_list[1]))

            self.df=pd.read_csv(self.domtblout,
                            delim_whitespace=True,
                            comment='#',
                            names=colnames_coltypes_list[0],
                            dtype=colnames_coltypes_dict,
                            header=None,
                            index_col=False)
        except Exception as e:
            print(e)
            raise ConfigError(f"Doesn't look like a --domtblout... anvi'o can't even... "
                              f"Please look at this error message to find out what happened: "
                              f"{e}")

        self.df['query_coverage'] = ((self.df['hmm_stop'] - self.df['hmm_start'])/ self.df['hmm_length'])
        self.df['target_coverage'] = ((self.df['gene_stop'] - self.df['gene_start'])/ self.df['gene_length'])


    def filter_domtblout(self):
        """Filter the hmm_hits table based on query and/or target coverage"""

        # Filtering conditions
        if self.query_coverage and self.target_coverage:
            df_filtered = self.df[(self.df['query_coverage'] > float(self.query_coverage)) & (self.df['target_coverage'] > float(self.target_coverage))]
        elif self.target_coverage:
            df_filtered = self.df[self.df['target_coverage'] > float(self.target_coverage)]
        elif self.query_coverage:
            df_filtered = self.df[self.df['query_coverage'] > float(self.query_coverage)]
        else:
            df_filtered = self.df.copy()

        self.run.info("Num hits before filtering", self.df.shape[0])
        self.run.info("Num hits after filtering", df_filtered.shape[0])
        self.run.info("Num filtered", self.df.shape[0] - df_filtered.shape[0])

        # Reformat domtblout back to original
        df_final = df_filtered.drop(columns=['query_coverage', 'target_coverage'])

        domtblout_tmp_out = filesnpaths.get_temp_file_path()
        df_final.to_csv(domtblout_tmp_out, sep = '\t', index=False)

        return domtblout_tmp_out


    def parse_domtblout(self, hmmsearch_tbl=None):
        """Parse the new, filtered domtblout file"""

        # Parse domtblout
        alphabet= 'AA'
        context= 'DOMAIN'
        hmm_program = 'hmmsearch'

        parser = parser_modules['search']['hmmer_table_output'](hmmsearch_tbl, alphabet=alphabet, context=context, program=hmm_program)
        search_results_dict = parser.get_search_results()

        return search_results_dict


    def append_search_results_dict_to_hmm_tables(self, search_results_dict=None):
        """Put in the new filtered hmm_hits table to the contigsDB"""

        # Remove old hmm_hits contigs_db_path
        hmm_tables = TablesForHMMHits(self.contigs_db_path)
        hmm_tables.remove_source(self.hmm_source)

        # Re-write hmm_hits table to contigsDB
        internal_sources = list(hmm_data.sources.keys())
        source = self.hmm_source

        if self.sources not in internal_sources:
            kind_of_search = self.sources[source]['kind']
            domain = self.sources[source]['domain']
            all_genes_searched_against = self.sources[source]['genes']
            reference = self.sources[source]['ref']
        else:
            sources = hmm_data.sources
            source = self.hmm_source
            kind_of_search = sources[source]['kind']
            domain = sources[source]['domain']
            all_genes_searched_against = sources[source]['genes']
            reference = self.sources[source]['ref']

        hmm_tables.append_to_hmm_hits_table(source, reference, kind_of_search, domain, all_genes_searched_against, search_results_dict)

        # add contigsDB self attributes for HMM_source, target_coverage, and query_coverage 
        self.db = db.DB(self.contigs_db_path, anvio.__contigs__version__, new_database=False)

        HMM_dom_filter_sources = self.db.get_meta_value('HMM_dom_filter_sources', return_none_if_not_in_table=True)
        HMM_dom_filter_target_coverage = self.db.get_meta_value('HMM_dom_filter_target_coverage', return_none_if_not_in_table=True)
        HMM_dom_filter_query_coverage = self.db.get_meta_value('HMM_dom_filter_query_coverage', return_none_if_not_in_table=True)

        if HMM_dom_filter_sources == None:
            self.db.set_meta_value('HMM_dom_filter_sources', source)
            if self.target_coverage == None:
                self.db.set_meta_value('HMM_dom_filter_target_coverage', 0.00)
            else:
                self.db.set_meta_value('HMM_dom_filter_target_coverage', self.target_coverage)
            if self.query_coverage == None:
                self.db.set_meta_value('HMM_dom_filter_query_coverage', 0.00)
            else:
                self.db.set_meta_value('HMM_dom_filter_query_coverage', self.query_coverage)
        else:
            HMM_dom_filter_sources_list = HMM_dom_filter_sources.split(",")
            HMM_dom_filter_target_coverage_list = str(HMM_dom_filter_target_coverage).split(",")
            HMM_dom_filter_query_coverage_list = str(HMM_dom_filter_query_coverage).split(",")

            source_domain_filter_values = list(zip(HMM_dom_filter_sources_list, HMM_dom_filter_target_coverage_list, HMM_dom_filter_query_coverage_list))

            if self.target_coverage == None:
                self.target_coverage = 0.00
            if self.query_coverage == None:
                self.query_coverage = 0.00

            new_filtering_parameters = (source, self.target_coverage, self.query_coverage)

            for i, item in enumerate(source_domain_filter_values):
                if new_filtering_parameters[0] == item[0]:
                    if float(item[1]) < float(new_filtering_parameters[1]) or float(item[2]) < float(new_filtering_parameters[2]):
                        source_domain_filter_values[i] = new_filtering_parameters

            if new_filtering_parameters[0] not in HMM_dom_filter_sources_list:
                source_domain_filter_values.append(new_filtering_parameters)

            updated_HMM_dom_filter_attributes = list(zip(*source_domain_filter_values))

            self.db.set_meta_value('HMM_dom_filter_sources', ','.join(str(s) for s in updated_HMM_dom_filter_attributes[0]))
            self.db.set_meta_value('HMM_dom_filter_target_coverage', ','.join(str(s) for s in updated_HMM_dom_filter_attributes[1]))
            self.db.set_meta_value('HMM_dom_filter_query_coverage', ','.join(str(s) for s in updated_HMM_dom_filter_attributes[2]))

        self.db.disconnect()


@terminal.time_program
def main(args):
    p = FilterHmmHitsTable(args)
    p.process()

if __name__ == '__main__':

    from anvio.argparse import ArgumentParser
    parser = ArgumentParser(description=__description__)

    parser.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db'))
    parser.add_argument(*anvio.A('hmm-source'), **anvio.K('hmm-source'))
    parser.add_argument(*anvio.A('list-hmm-sources'), **anvio.K('list-hmm-sources'))
    parser.add_argument(*anvio.A('hmm-profile-dir'), **anvio.K('hmm-profile-dir'))
    parser.add_argument('--domain-hits-table', metavar='PATH', help="Please provide the path to the domain-table-output. You can get this file from running anvi-run-hmms with the flag --domain-hits-table.")
    parser.add_argument('--target-coverage',
                        help=" (ali_coord_to - ali_coord_from)/target_length")
    parser.add_argument('--query-coverage',
                        help=" (hmm_coord_to - hmm_coord_from)/hmm_length")

    args, unknown = parser.parse_known_args()

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
