#!/usr/bin/env python
# -*- coding: utf-8

import os
import sys

import anvio
import anvio.kegg as kegg
import anvio.utils as utils

import anvio.terminal as terminal

from anvio.errors import ConfigError,FilesNPathsError
from anvio.genomedescriptions import GenomeDescriptions

__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2020, the Meren Lab (http://merenlab.org/)"
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Iva Veseli"
__email__ = "iveseli@uchicago.edu"
__requires__ = ["kegg-metabolism","external-genomes"]
__provides__ = []
__description__ = "An ad-hoc script to analyze KEGG modules from metabolism estimation output"

run = terminal.Run()
progress = terminal.Progress()


## CLASSES AND FUNCTION DEFINITIONS
## Ideally, these will eventually go into a separate file.
class ModuleAnalyzer:
    """This class defines functions for analysis of metabolic modules."""

    def __init__(self, args, run=run, progress=progress):
        self.args = args
        self.run = run
        self.progress = progress

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.external_genomes_file = A('external_genomes') or None

        g = GenomeDescriptions(self.args, run=self.run, progress=self.progress)
        g.load_genomes_descriptions(skip_functions=True, init=False)
        self.genomes = g.genomes

        self.input_paths_sanity_check()


    def input_paths_sanity_check(self):
        """Make sure each genome has a metabolism input file path, and convert to absolute paths if necessary."""

        for genome_name in self.genomes:
            if 'metabolism_output_path' not in self.genomes[genome_name]:
                raise ConfigError(f"Your input file should contain a column called 'metabolism_output_path' "
                                  f"containing paths to metabolism estimation output files for each genome, "
                                  f"buuuut it doesn't, so... see ya.")

            path = self.genomes[genome_name]['metabolism_output_path']
            if not path:
                raise ConfigError(f"Your input file did not contain a path to metabolism output "
                                  f"for genome {genome_name}. Better fix that or this whole thing "
                                  f"won't work.")

            if not path.startswith('/'):
                self.genomes[genome_name]['metabolism_output_path'] = os.path.abspath(os.path.join(os.path.dirname(self.external_genomes_file), path))


    def analyze_modules(self):
        """Driver function for module analysis.

        We go through each genome and process its module estimation output file. Each time we find a new module, we initialize
        a module object to keep track of its data.
        """

        self.modules = {}
        # these expected headers should make sure we are working only with single genome metabolism estimation output files
        expected_headers = kegg.OUTPUT_MODES['modules']['headers'] + ['genome_name']

        for genome in self.genomes:
            input_file = self.genomes[genome]['metabolism_output_path']
            modules_file_dict = utils.get_TAB_delimited_file_as_dictionary(input_file, expected_fields=expected_headers)

            for id in modules_file_dict:
                module_info_in_genome = modules_file_dict[id]
                corresponding_genome = module_info_in_genome['genome_name']

                if corresponding_genome != genome:
                    raise ConfigError(f"In the metabolism output file for genome '{genome}' (which is {input_file}, by "
                                      f"the way) we found a line that does not correspond to this genome.Â The fishy "
                                      f"'genome_name' column has the genome '{corresponding_genome}' instead. Maybe you "
                                      f"gave us the wrong file, or maybe you gave us the wrong genome name, but either "
                                      f"way, you should make sure the names correspond.")

                module_id = module_info_in_genome['kegg_module']
                if module_id not in self.modules:
                    self.modules[module_id] = Module(module_info_in_genome)
class Module:
    """This class represents one metabolic module, and summarizes information about this module in all input genomes.

    This includes information about gene order and synteny, KOs that are commonly used/missing, etc.

    You can initialize this class using a dictionary of the module's information. It is most convenient to get this information
    from a line of a modules mode metabolism estimation output file. but you can also generate your own dictionary.

    Here is an example, which shows the requisite headers in that dictionary:
    >>> mod = Module({'kegg_module': 'M00001', 'module_name': 'Glycolysis (Embden-Meyerhof pathway), glucose => pyruvate', \
                      'module_class': 'Pathway modules', 'module_category': 'Carbohydrate metabolism', \
                      'module_subcategory': 'Central carbohydrate metabolism', \
                      'module_definition': '"(K00844,K12407,K00845,K00886,K08074,K00918) (K01810,K06859,K13810,K15916) (K00850,K16370,K21071,K00918) (K01623,K01624,K11645,K16305,K16306) K01803 ((K00134,K00150) K00927,K11389) (K01834,K15633,K15634,K15635) K01689 (K00873,K12406)"', \
                      'module_warnings': 'None'})
    """

    def __init__(self, mod_info_in_one_genome):
        # initialize attributes that will never change
        self.id = mod_info_in_one_genome['kegg_module']
        self.name = mod_info_in_one_genome['module_name']
        self.module_class = mod_info_in_one_genome['module_class']
        self.category = mod_info_in_one_genome['module_category']
        self.subcategory = mod_info_in_one_genome['module_subcategory']
        self.definition = mod_info_in_one_genome['module_definition'].strip('"')
        self.warnings = mod_info_in_one_genome['warnings']

        # initialize summary attributes
        self.gcid_distances = []            # the distances between subsequent gene calls within one genome (saved for each genome)
        self.completeness_scores = []       # completeness of this module in each genome


    def __repr__(self):
        return f"Module(id={self.id}, name={self.name}, class={self.module_class}, category={self.category}, subcategory={self.subcategory}, " \
               f"definition={self.definition})"


    def __str__(self):
        return f"Module ID: {self.id}\nName: {self.name}\nClass: {self.module_class}\nCategory: {self.category}\nSubcategory: {self.subcategory}\n" \
               f"Definition: {self.definition}"


## END CLASSES AND FUNCTION DEFINITIONS
## Script driver
def main(args):
    """The main driver function for analyzing modules."""

    a = ModuleAnalyzer(args)
    a.analyze_modules()


if __name__ == '__main__':
    from anvio.argparse import ArgumentParser

    parser = ArgumentParser(description=__description__)

    groupI = parser.add_argument_group('INPUT')
    groupI.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes',
                                {'help': "A TAB-delimited flat text file that lists anvi'o contigs databases. "
                                 "In addition to the standard 'name' and 'contigs_db_path' columns, it must "
                                 "also include a 'metabolism_output_path' column which lists the path to "
                                 "the modules mode output from anvi-estimate-metabolism for this genome. NOTE: "
                                 "the 'name' column of this external genomes file must correspond to the 'genome_name' "
                                 "column in the metabolism output file indicated in the 'metabolism_output_path' column."}))

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)
