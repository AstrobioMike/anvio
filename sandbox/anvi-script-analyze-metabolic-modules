#!/usr/bin/env python
# -*- coding: utf-8

import os
import sys

import anvio
import anvio.kegg as kegg
import anvio.utils as utils
import anvio.tables as t

import anvio.terminal as terminal

from anvio.errors import ConfigError,FilesNPathsError
from anvio.genomedescriptions import GenomeDescriptions
from anvio.dbops import ContigsDatabase

__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2020, the Meren Lab (http://merenlab.org/)"
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Iva Veseli"
__email__ = "iveseli@uchicago.edu"
__requires__ = ["kegg-metabolism","external-genomes"]
__provides__ = []
__description__ = "An ad-hoc script to analyze KEGG modules from metabolism estimation output"

run = terminal.Run()
progress = terminal.Progress()


## CLASSES AND FUNCTION DEFINITIONS
## Ideally, these will eventually go into a separate file.
class ModuleAnalyzer:
    """This class defines functions for analysis of metabolic modules."""

    def __init__(self, args, run=run, progress=progress):
        self.args = args
        self.run = run
        self.progress = progress

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.external_genomes_file = A('external_genomes') or None

        g = GenomeDescriptions(self.args, run=self.run, progress=self.progress)
        g.load_genomes_descriptions(skip_functions=True, init=False)
        self.genomes = g.genomes

        self.input_paths_sanity_check()


    def input_paths_sanity_check(self):
        """Make sure each genome has a metabolism input file path, and convert to absolute paths if necessary."""

        for genome_name in self.genomes:
            if 'metabolism_output_path' not in self.genomes[genome_name]:
                raise ConfigError(f"Your input file should contain a column called 'metabolism_output_path' "
                                  f"containing paths to metabolism estimation output files for each genome, "
                                  f"buuuut it doesn't, so... see ya.")

            path = self.genomes[genome_name]['metabolism_output_path']
            if not path:
                raise ConfigError(f"Your input file did not contain a path to metabolism output "
                                  f"for genome {genome_name}. Better fix that or this whole thing "
                                  f"won't work.")

            if not path.startswith('/'):
                self.genomes[genome_name]['metabolism_output_path'] = os.path.abspath(os.path.join(os.path.dirname(self.external_genomes_file), path))


    def analyze_modules(self):
        """Driver function for module analysis.

        We go through each genome and process its module estimation output file. Each time we find a new module, we initialize
        a module object to keep track of its data.
        """

        self.modules = {}
        # these expected headers should make sure we are working only with single genome metabolism estimation output files
        expected_headers = kegg.OUTPUT_MODES['modules']['headers'] + ['genome_name']

        for genome in self.genomes:
            input_file = self.genomes[genome]['metabolism_output_path']
            modules_file_dict = utils.get_TAB_delimited_file_as_dictionary(input_file, expected_fields=expected_headers)

            # we open the contigs db so we can access contig information
            contigs_db_path = self.genomes[genome]['contigs_db_path']
            contigs_db = ContigsDatabase(contigs_db_path, run=self.run, progress=self.progress)
            genes_in_contigs = contigs_db.db.get_some_columns_from_table(t.genes_in_contigs_table_name, "gene_callers_id, contig")
            gene_to_contig_dict = {gene: contig for gene,contig in genes_in_contigs}

            for id in modules_file_dict:
                module_info_in_genome = modules_file_dict[id]
                corresponding_genome = module_info_in_genome['genome_name']

                if corresponding_genome != genome:
                    raise ConfigError(f"In the metabolism output file for genome '{genome}' (which is {input_file}, by "
                                      f"the way) we found a line that does not correspond to this genome.Â The fishy "
                                      f"'genome_name' column has the genome '{corresponding_genome}' instead. Maybe you "
                                      f"gave us the wrong file, or maybe you gave us the wrong genome name, but either "
                                      f"way, you should make sure the names correspond.")

                module_id = module_info_in_genome['kegg_module']
                if module_id not in self.modules:
                    self.modules[module_id] = Module(module_info_in_genome)

                self.modules[module_id].add_genome_data(module_info_in_genome, gene_to_contig_dict)

            contigs_db.disconnect()

        for mod in self.modules:
            self.modules[mod].summarize()


class Module:
    """This class represents one metabolic module, and summarizes information about this module in all input genomes.

    This includes information about gene order and synteny, KOs that are commonly used/missing, etc.

    You can initialize this class using a dictionary of the module's information. It is most convenient to get this information
    from a line of a modules mode metabolism estimation output file. but you can also generate your own dictionary.

    Here is an example, which shows the requisite headers in that dictionary:
    >>> mod = Module({'kegg_module': 'M00001', 'module_name': 'Glycolysis (Embden-Meyerhof pathway), glucose => pyruvate', \
                      'module_class': 'Pathway modules', 'module_category': 'Carbohydrate metabolism', \
                      'module_subcategory': 'Central carbohydrate metabolism', \
                      'module_definition': '"(K00844,K12407,K00845,K00886,K08074,K00918) (K01810,K06859,K13810,K15916) (K00850,K16370,K21071,K00918) (K01623,K01624,K11645,K16305,K16306) K01803 ((K00134,K00150) K00927,K11389) (K01834,K15633,K15634,K15635) K01689 (K00873,K12406)"', \
                      'module_warnings': 'None'})
    """

    def __init__(self, mod_info_in_one_genome):
        # initialize attributes that will never change
        self.id = mod_info_in_one_genome['kegg_module']
        self.name = mod_info_in_one_genome['module_name']
        self.module_class = mod_info_in_one_genome['module_class']
        self.category = mod_info_in_one_genome['module_category']
        self.subcategory = mod_info_in_one_genome['module_subcategory']
        self.definition = mod_info_in_one_genome['module_definition'].strip('"')
        self.warnings = mod_info_in_one_genome['warnings']

        # initialize summary attributes
        self.gcid_distances = []            # the distances between subsequent gene calls within one genome (saved for each genome)
        self.completeness_scores = []       # completeness of this module in each genome
        self.ko_data = {}                   # KO statistics, like adjacency matrix and frequency

        for k in self.get_kos_from_definition():
            # frequency - number of times we observe this KO across all genomes
            # adjacency - which KOs we observe immediately adjacent to this KO (key), and how many times that happens (value)
            self.ko_data[k] = {'frequency': 0, 'adjacency': {}}


    def __repr__(self):
        return f"Module(id={self.id}, name={self.name}, class={self.module_class}, category={self.category}, subcategory={self.subcategory}, " \
               f"definition={self.definition})"


    def __str__(self):
        return f"Module ID: {self.id}\nName: {self.name}\nClass: {self.module_class}\nCategory: {self.category}\nSubcategory: {self.subcategory}\n" \
               f"Definition: {self.definition}"


    def get_kos_from_definition(self):
        """This function returns a list of KOs in the given module, in order of the DEFINITION (self.definition)"""

        ko_list = []
        k_indices = [x for x, v in enumerate(self.definition) if v == 'K']
        for idx in k_indices:
            ko_list.append(self.definition[idx:idx+6])

        return ko_list


    def add_genome_data(self, mod_info_in_one_genome, genes_to_contigs_in_genome):
        """Processes a line from metabolism estimation output for this module in one genome and adds data to summary attributes.

        The line should be in dictionary form and the required keys are the headers in that metabolism estimation output file,
        which are: kegg.OUTPUT_MODES['modules']['headers'] + ['genome_name']

        PARAMETERS
        ==========
        mod_info_in_one_genome : dict
            one line of metabolism estimation modules mode output for current genome, in dictionary form.
            See class docstring for partial example.
        genes_to_contigs_in_genome : dict
            dictionary where keys are gene caller ids and values are contigs where the gene is located, for current genome.
        """

        data_mod_id = mod_info_in_one_genome['kegg_module']
        if data_mod_id != self.id:
            raise ConfigError(f"Ooopsie. You gave Module.add_genome_data() some data that is for the wrong module. This Module object "
                              f"has the id '{self.id}', but the data is for module '{data_mod_id}'.")

        self.completeness_scores.append(float(mod_info_in_one_genome['module_completeness']))

        gcids_in_mod = [int(x) for x in mod_info_in_one_genome['gene_caller_ids_in_module'].split(",")]
        kos_in_mod = mod_info_in_one_genome['kofam_hits_in_module'].split(",")
        if len(gcids_in_mod) != len(kos_in_mod):
            raise ConfigError(f"Something is terribly wrong. In genome '{mod_info_in_one_genome['genome_name']}', the KO string "
                              f"does not have the same length as the gene caller id string for module {self.id}.")
        gcid_to_ko_dict = {gcid: ko for gcid,ko in zip(gcids_in_mod, kos_in_mod)}

        # this will only work with gcids on same contig, so let's figure out which those are
        contigs_to_genes_dict = {}
        sorted_gcids = sorted(gcids_in_mod)
        for gene in sorted_gcids:
            on_contig = genes_to_contigs_in_genome[gene]
            if on_contig not in contigs_to_genes_dict:
                contigs_to_genes_dict[on_contig] = [gene]
            else:
                contigs_to_genes_dict[on_contig].append(gene)

        # we only compile KO data for modules that are defined by KOs, not by other modules
        if self.ko_data:
            # compute KO frequency
            for k in kos_in_mod:
                self.ko_data[k]['frequency'] += 1

            for contig in contigs_to_genes_dict:
                genes_on_contig = contigs_to_genes_dict[contig] # these are already sorted from low to high

                for i in range(1, len(genes_on_contig)):
                    gene1 = genes_on_contig[i-1]
                    gene2 = genes_on_contig[i]
                    ko1 = gcid_to_ko_dict[gene1]
                    ko2 = gcid_to_ko_dict[gene2]

                    # compute distances between adjacent genes
                    dist_between_genes = gene2 - gene1
                    self.gcid_distances.append(dist_between_genes)

                    # determine KO adjacency
                    if ko1 not in self.ko_data[ko2]['adjacency']:
                        self.ko_data[ko2]['adjacency'][ko1] = 1
                    else:
                        self.ko_data[ko2]['adjacency'][ko1] += 1

                    if ko1 != ko2: # avoid double-counting twins
                        if ko2 not in self.ko_data[ko1]['adjacency']:
                            self.ko_data[ko1]['adjacency'][ko2] = 1
                        else:
                            self.ko_data[ko1]['adjacency'][ko2] += 1


    def summarize(self):
        """Summarizes the collected module data from across all genomes.

        RETURNS
        =======
        self.always_complete : boolean
            True if completeness was 1.0 in all genomes
        self.is_operon : boolean
            True if distance between each subsequent gene (that we know are on same contig) is 1, across all genomes
        self.no_synteny_info : boolean
            True if no genes in the module are on the same contig in any genome
        """

        self.avg_completeness = sum(self.completeness_scores) / len(self.completeness_scores)
        self.avg_gene_distance = None
        if self.gcid_distances:
            self.avg_gene_distance = sum(self.gcid_distances) / len(self.gcid_distances)

        self.is_operon = False
        self.always_complete = False
        self.no_synteny_info = False
        if self.avg_gene_distance == 1.0:
            self.is_operon = True
        if self.avg_completeness == 1.0:
            self.always_complete = True
        if not self.avg_gene_distance:
            self.no_synteny_info = True

        return self.always_complete, self.is_operon, self.no_synteny_info


## END CLASSES AND FUNCTION DEFINITIONS
## Script driver
def main(args):
    """The main driver function for analyzing modules."""

    a = ModuleAnalyzer(args)
    a.analyze_modules()


if __name__ == '__main__':
    from anvio.argparse import ArgumentParser

    parser = ArgumentParser(description=__description__)

    groupI = parser.add_argument_group('INPUT')
    groupI.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes',
                                {'help': "A TAB-delimited flat text file that lists anvi'o contigs databases. "
                                 "In addition to the standard 'name' and 'contigs_db_path' columns, it must "
                                 "also include a 'metabolism_output_path' column which lists the path to "
                                 "the modules mode output from anvi-estimate-metabolism for this genome. NOTE: "
                                 "the 'name' column of this external genomes file must correspond to the 'genome_name' "
                                 "column in the metabolism output file indicated in the 'metabolism_output_path' column."}))

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)
