#!/usr/bin/env python
# -*- coding: utf-8
"""
Citations: doi:10.1126/science.aaz9642, doi:10.1038/nature11711
"""

import os
import sys

import numpy as np
import pandas as pd

import anvio

import anvio.dbops as dbops
import anvio.utils as utils
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.filesnpaths as filesnpaths

from anvio.argparse import ArgumentParser
from anvio.errors import ConfigError, FilesNPathsError
from anvio.variabilityops import VariabilityData

from numba import jit

__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2018, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Evan Kiefl"
__email__ = "kiefl.evan@gmail.com"
__provides__ = ['pn-ps-data']
__requires__ = ['contigs-db', 'variability-profile-txt']
__description__ = ("FIXME")


progress = terminal.Progress()
run = terminal.Run()


def load_variability(args, contigs_db):
    progress.new('Loading SCVs')
    progress.update('...')

    var = VariabilityData(args)

    # filter based on user parameters
    var.filter_data(criterion='departure_from_consensus', verbose=False)
    var.filter_data(criterion='departure_from_reference', verbose=False)
    var.filter_data(criterion='coverage', verbose=False)

    # identify gene calls that are noncoding
    gene_caller_ids_for_noncoding_gene_calls = [g for g in var.data['corresponding_gene_call'].unique()
                                                if contigs_db.genes_in_contigs_dict[g]['call_type'] != constants.gene_call_types['CODING']]
    if gene_caller_ids_for_noncoding_gene_calls:
        # This should never happen with >v6.2
        var.data.drop(var.data[var.data['corresponding_gene_call'].isin(gene_caller_ids_for_noncoding_gene_calls)].index, inplace=True)

        progress.reset()
        run.warning("%d of your gene calls were 'noncoding', and were removed from downstream analyses. Here is the complete list of "
                    "gene calls that were removed: '%s'." % (len(gene_caller_ids_for_noncoding_gene_calls), ', '.join([str(g) for g in gene_caller_ids_for_noncoding_gene_calls])))

    progress.end()

    return var.data


def load_contigs_db(args):
    filesnpaths.is_file_exists(args.contigs_db)
    contigs_db = dbops.ContigsSuperclass(args, r=terminal.Run(verbose=False), p=terminal.Progress(verbose=False))
    contigs_db.init_contig_sequences()
    return contigs_db


def report(args, pNpS, pN, pS):
    index_label = "gene_callers_id"

    # write it to folder
    pNpS.to_csv(os.path.join(args.output_dir, "pNpS.txt"), sep="\t", index = True, index_label = index_label)
    pN.to_csv(os.path.join(args.output_dir, "pN.txt"), sep="\t", index = True, index_label = index_label)
    pS.to_csv(os.path.join(args.output_dir, "pS.txt"), sep="\t", index = True, index_label = index_label)

    run.info_single("Done! Contents have been output to the directory '{}'.".format(args.output_dir),
                    nl_before=1,
                    nl_after=1)


def calculate_pN_pS_ratio(args):
    # gen output
    filesnpaths.check_output_directory(args.output_dir)
    filesnpaths.gen_output_directory(args.output_dir)

    # load contigs db and variability table
    contigs_db = load_contigs_db(args)
    df = load_variability(args, contigs_db)

    # Track stop coverages so that they can be deducted from the polymorphism coverage
    stop_codons = set(constants.codons) - set(constants.coding_codons)
    df['stop_coverage'] = df[list(stop_codons)].sum(axis=1)

    comparison = args.comparison

    progress.new('Calculating pN and pS')

    # Some conversion dictionaries
    coding_codons = sorted(constants.coding_codons)
    codon_to_num = {coding_codons[i]: i for i in range(len(coding_codons))}
    num_to_codon = {v: k for k, v in codon_to_num.items()}
    codon_nums = np.arange(len(coding_codons))

    # We need the comparison column represented as numerical for numba
    comparison_array = df[comparison].map(codon_to_num).fillna(-1).values.astype(int)

    is_synonymous = np.zeros((len(coding_codons), len(coding_codons))).astype(bool)
    for i, codon1 in enumerate(coding_codons):
        for j, codon2 in enumerate(coding_codons):
            if constants.codon_to_AA[codon1] == constants.codon_to_AA[codon2]:
                is_synonymous[i, j] = True
            else:
                is_synonymous[i, j] = False

    potentials = np.zeros((len(coding_codons), 2))
    for i, codon in num_to_codon.items():
        s_pot, ns_pot, _ = utils.get_synonymous_and_non_synonymous_potential([codon], just_do_it=True)
        potentials[i, 0] = s_pot
        potentials[i, 1] = ns_pot

    counts_array = df[constants.coding_codons].values
    coverage = df['coverage'].values
    stop_coverage = df['stop_coverage'].values

    progress.update("You're ungrateful if you think this is slow")
    pNs, pSs = _calculate_pN_pS_ratio(
        counts_array,
        comparison_array,
        coverage,
        stop_coverage,
        codon_nums,
        potentials,
        is_synonymous,
    )

    progress.end()

    df['pN'] = pNs
    df['pS'] = pSs

    # Reshape into matrix output
    pN = df.\
        groupby(['sample_id', 'corresponding_gene_call'])\
        ['pN'].\
        sum().\
        reset_index().\
        pivot(columns='sample_id', index='corresponding_gene_call', values='pN')

    pS = df.\
        groupby(['sample_id', 'corresponding_gene_call'])\
        ['pS'].\
        sum().\
        reset_index().\
        pivot(columns='sample_id', index='corresponding_gene_call', values='pS')

    pNpS = pN/pS

    report(args, pNpS, pN, pS)


@jit(nopython=True)
def _calculate_pN_pS_ratio(counts_array, comparison_array, coverage, stop_coverage, codon_nums, potentials, is_synonymous):
    pNs, pSs = [], []
    for i in range(counts_array.shape[0]):
        comp = comparison_array[i] # The codon to be compared against
        pN, pS = 0, 0

        if comp < 0:
            # No sense talking about synonymity relative to a stop codon
            pNs.append(np.nan)
            pSs.append(np.nan)
        else:
            for codon in codon_nums:
                if codon == comp:
                    # Don't compare the reference codon with itself, we care only about codons that
                    # differ from the reference codon
                    continue

                if is_synonymous[comp, codon]:
                    pS += counts_array[i, codon]
                else:
                    pN += counts_array[i, codon]

            s_potential, ns_potential = potentials[comp, :]
            cov = coverage[i] - stop_coverage[i] - counts_array[i, comp]

            if pN == 0:
                pNs.append(0)
            else:
                pN = pN / cov / ns_potential
                pNs.append(pN)

            if pS == 0:
                pSs.append(0)
            else:
                pS = pS / cov / s_potential
                pSs.append(pS)

    return pNs, pSs


if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    groupV = parser.add_argument_group('VARIABILITY', 'Provide a SCV table that can be generated with anvi-gen-variability-profile.')
    groupV.add_argument('-V', '--variability-profile', help='Filepath to the SCV table.', metavar='SCV_FILE')
    groupV.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db', {'help':'Filepath to the contigs database used \
                                                      to generate variability table.'}))

    groupE = parser.add_argument_group('TUNABLES', "Successfully tune one or more of these parameters to unlock the badge 'Advanced anvian'.")
    groupE.add_argument(*anvio.A('min-departure-from-consensus'), **anvio.K('min-departure-from-consensus', {'default': 0.1, 'help': \
                            'SCVs will be ignored if they have a departure from consensus less than this \
                            value. Note: Keep in mind you may have already supplied this parameter during anvi-gen-variability-profile.\
                            The default value is %(default).2f.'}))
    groupE.add_argument(*anvio.A('min-departure-from-reference'), **anvio.K('min-departure-from-reference', {'default': 0.1, 'help': \
                            'SCVs will be ignored if they have a departure from reference less than this \
                            value. Note: Keep in mind you may have already supplied this parameter during anvi-gen-variability-profile.\
                            The default value is %(default).2f.'}))
    groupE.add_argument('-i', '--minimum-num-variants', default=4, type=int, required=False, help='Ignore genes with less than this number\
                            of single codon variants. FIXME')
    groupE.add_argument('-m', '--min-coverage', default=30, type=int, required=False, help='If the coverage value at a codon is less than \
                            this amount, any associated SCVs will be ignored. The default is %(default)d.')
    groupE.add_argument('-x', '--comparison', default='reference', choices=['reference', 'consensus'], help='You can determine synonymity \
                            relative to either the reference codon, or the consensus codon. The consensus codon is determined on a per-sample \
                            basis. The default is \'%(default)s.\'')

    groupO = parser.add_argument_group('OUTPUT', 'The output of this program is a folder directory with several tables.')
    groupO.add_argument(*anvio.A('output-dir'), **anvio.K('output-dir', {'required':True}))

    args = parser.get_args(parser)
    args.columns_to_load = constants.codons + [
        'corresponding_gene_call',
        'sample_id',
        'coverage',
        'departure_from_consensus',
        'departure_from_reference',
        args.comparison
    ]

    try:
        calculate_pN_pS_ratio(args)
    except ConfigError as e:
        print(e)
        sys.exit(1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(1)
