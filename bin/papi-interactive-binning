#!/usr/bin/env python
# -*- coding: utf-8

"""
Copyright (C) 2014, PaPi Team

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

Please read the COPYING file.
"""

import os
import sys
import json
import base64
import shutil
import cPickle
import argparse
import tempfile
import webbrowser

from bottle import route, run, static_file, redirect, request, BaseRequest, response
from Bio import Phylo

import PaPi.utils
import PaPi.fastalib as u
# get the absolute path for static directory under PaPi
static_dir = os.path.join(os.path.dirname(u.__file__), 'static')

parser = argparse.ArgumentParser(description='Start PaPi binning interface')
# FIXME: it should be possible to run this without the runinfo-dict.
parser.add_argument('-r', '--runinfo', metavar = 'cPickle', default = None,
                    help = 'RUNINFO.cPickle file generated by a PaPi profiler')
parser.add_argument('-f', '--fasta-file', metavar = 'FASTA', default = None,
                    help = 'FASTA file of consensus sequences for each contig')
parser.add_argument('-m', '--metadata', metavar = 'TXT', default = None,
                    help = 'TAB-delimited metadata file')
parser.add_argument('-t', '--tree', metavar = 'NEWICK', default = None,
                    help = 'Newick tree of contigs')
parser.add_argument('-o', '--output-dir', metavar = 'DIRECTORY', default = None,
                    help = 'Output directory for output storage')
parser.add_argument('-p', '--port-number', metavar = 'INT', default = 8080, type=int,
                    help = 'Port number to use for communication; the default\
                            (%(default)d) should be OK for almost everyone.')

#######################################################################################################################
# Input handler
#######################################################################################################################

class RuninfoIO:
    def __init__(self, args):
        self.runinfo = {}
        self.contigs = {}

        self.cwd = os.getcwd()

        if args.runinfo:
            # runinfo dict provided: we don't want anything else
            if args.fasta_file or args.metadata or args.tree:
                raise PaPi.utils.ConfigError, "You declared a RUNINFO dict with '-r'. You are not allowed to\
                                               declare any of '-f', '-m', or '-t' parameters if you have a\
                                               RUNINFO dict. Please refer to the documentation."

            self.runinfo = cPickle.load(open(args.runinfo))
            self.runinfo['self_path'] = args.runinfo

        else:
            # self.runinfo *must* contain 'tnf_tree', 'metadata_json', 'output_dir' and 'self_path'.
            if (not args.fasta_file) or (not args.metadata) or (not args.tree) or (not args.output_dir):
                raise PaPi.utils.ConfigError, "If you do not have a RUNINFO dict, you must declare each of\
                                               '-f', '-m', '-t' and '-o' parameters. Please see '--help' for\
                                               more detailed information on them."

            ABS = lambda x: x if x.startswith('/') else os.path.join(os.getcwd(), x)
            self.runinfo['tnf_tree'] = ABS(args.tree)
            self.runinfo['contigs_fasta'] = ABS(args.fasta_file)
            self.runinfo['metadata_txt'] = ABS(args.metadata)
            self.runinfo['output_dir'] = ABS(args.output_dir)

            # sanity of the metadata
            #PaPi.utils.is_file_json_formatted(args.metadata)
            PaPi.utils.is_file_tab_delimited(self.runinfo['metadata_txt'])
            if not open(self.runinfo['metadata_txt']).readline().split('\t')[0] == "contigs":
                raise PaPi.utils.ConfigError, "The first row of the first column of the metadata file must\
                                               say 'contigs', which is not the case for your metadata file\
                                               ('%s'). Please make sure this is a properly formatted metadata\
                                               file." % (self.runinfo['metadata_txt'])
            PaPi.utils.is_file_fasta_formatted(self.runinfo['contigs_fasta'])

            self.runinfo['self_path'] = os.path.join(self.runinfo['output_dir'], 'RUNINFO.cPickle')

            contigs_in_tree = sorted([t.name for t in Phylo.parse(self.runinfo['tnf_tree'], "newick").next().get_terminals()])
            contigs_in_metadata = sorted([l.split('\t')[0] for l in open(self.runinfo['metadata_txt']).readlines()[1:]])
            contigs_in_fasta = sorted(PaPi.utils.get_all_ids_from_fasta(self.runinfo['contigs_fasta']))

            try:
                assert(contigs_in_fasta == contigs_in_tree == contigs_in_metadata)
            except:
                # FIXME: tell the user which file F's it up.
                raise PaPi.utils.ConfigError, "Contigs name found in the FASTA file, the tree file and the\
                                               metadata needs to match perfectly. It seems it is not the\
                                               case for the input you provided."

            # convert metadata into json.
            f = tempfile.NamedTemporaryFile(delete=False)
            f.write(PaPi.utils.get_json_obj_from_TAB_delim_metadata(self.runinfo['metadata_txt']))
            f.close()
            self.runinfo['metadata_json'] = f.name

            if not os.path.exists(self.runinfo['output_dir']):
                os.makedirs(self.runinfo['output_dir'])

        fasta = u.SequenceSource(self.runinfo['contigs_fasta'])
        while fasta.next():
            self.contigs[fasta.id] = fasta.seq

    def update_runinfo_on_disk(self):
        path = self.runinfo.pop('self_path')
        cPickle.dump(self.runinfo, open(path, 'w'))


    def end(self):
        # FIXME: remove temp files and stuff
        pass

try:
    d = RuninfoIO(parser.parse_args())
except PaPi.utils.ConfigError, e:
    print e
    sys.exit(-1)


#######################################################################################################################
# bottle callbacks
#######################################################################################################################

@route('/')
def redirect_to_app():
    redirect('/app/index.html')

@route('/app/:filename#.*#')
def send_static(filename):
    response.set_header('Content-Type', 'application/json')
    response.set_header('Pragma', 'no-cache')
    response.set_header('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate')
    response.set_header('Expires', 'Thu, 01 Dec 1994 16:00:00 GMT')
    return static_file(filename, root=static_dir)

@route('/data/<name>')
def send_data(name):
    response.set_header('Content-Type', 'application/json')
    response.set_header('Pragma', 'no-cache')
    response.set_header('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate')
    response.set_header('Expires', 'Thu, 01 Dec 1994 16:00:00 GMT')
    if name == "tree":
        return static_file(d.runinfo['tnf_tree'], root ='/')
    elif name == "meta":
        return static_file(d.runinfo['metadata_json'], root='/')

@route('/submit', method='POST')
def get_data():
    bins = json.loads(request.forms.get('groups'))

    if not bins:
        return

    # take care of the SVG.
    svg_output_path = os.path.join(d.runinfo['output_dir'], 'BINS.svg')
    print '* Storing SVG data into "%s"' % svg_output_path
    svg_output = open(svg_output_path, 'w')
    svg_output.write(base64.b64decode(request.forms.get('svg')))
    svg_output.close()
    d.runinfo['bins_svg'] = svg_output_path

    # take care of bins.. start by removing the bins dir if it exists.
    bins_dir = os.path.join(d.runinfo['output_dir'], 'BINS')
    if os.path.exists(bins_dir):
        shutil.rmtree(bins_dir)
    os.makedirs(bins_dir)
    d.runinfo['bins'] = {} 
    print '* Storing bins under "%s"' % bins_dir
    for bin in bins:
        output_path = os.path.join(d.runinfo['output_dir'], 'BINS', bin + '.fa')
        output = open(output_path, 'w')
        for contig in bins[bin]:
            output.write('>%s\n%s\n' % (contig, d.contigs[contig]))
        output.close()
        d.runinfo['bins'][bin] = output_path

    # update RUNINFO dict...
    print '* Storing updated RUNINFO.cPickle'
    d.update_runinfo_on_disk()
    print


port = parser.parse_args().port_number

# increase maximum size of form data to 100 MB
BaseRequest.MEMFILE_MAX = 1024 * 1024 * 100 
webbrowser.open_new("http://127.0.0.1:%d" % port)
run(host='127.0.0.1', port=port, quiet=True)


