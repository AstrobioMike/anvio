#!/usr/bin/env python
# -*- coding: utf-8

"""
Copyright (C) 2014, 

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

Please read the COPYING file.
"""

import os
import sys
import json
import base64
import shutil
import cPickle
import argparse
import webbrowser
from bottle import route, run, static_file, redirect, request, BaseRequest, response

import PaPi.fastalib as u
# get the absolute path for static directory under PaPi
static_dir = os.path.join(os.path.dirname(u.__file__), 'static')

parser = argparse.ArgumentParser(description='Start the binning interface')
# FIXME: it should be possible to run this without the runinfo-dict.
parser.add_argument('-r', '--runinfo-dict', metavar = 'FILE', default = None,
                    help = 'RUNINFO.cPickle file generated by a PaPi profiler')
parser.add_argument('-p', '--port-number', metavar = 'INT', default = 8080, type=int,
                    help = 'Port number to use for communication; the default\
                            (%(default)d) should be OK for almost everyone.')

args = parser.parse_args()

# FIXME: I will come back to this later.
if not args.runinfo_dict:
    print 'Gotta give us sum runinfo dict.'
    sys.exit()

runinfo_dict = cPickle.load(open(args.runinfo_dict))

# first read the FASTA file into the memory.
contigs = {}
fasta = u.SequenceSource(runinfo_dict['contigs_fasta'])
while fasta.next():
    contigs[fasta.id] = fasta.seq


#######################################################################################################################
# bottle callbacks
#######################################################################################################################

@route('/')
def redirect_to_app():
    redirect('/app/index.html')

@route('/app/:filename#.*#')
def send_static(filename):
    response.set_header('Content-Type', 'application/json')
    response.set_header('Pragma', 'no-cache')
    response.set_header('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate')
    response.set_header('Expires', 'Thu, 01 Dec 1994 16:00:00 GMT')
    return static_file(filename, root=static_dir)

@route('/data/<name>')
def send_data(name):
    response.set_header('Content-Type', 'application/json')
    response.set_header('Pragma', 'no-cache')
    response.set_header('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate')
    response.set_header('Expires', 'Thu, 01 Dec 1994 16:00:00 GMT')
    if name == "tree":
        return static_file(runinfo_dict['tnf_tree'], root ='/')
    elif name == "meta":
        return static_file(runinfo_dict['metadata_json'], root='/')

@route('/submit', method='POST')
def get_data():
    bins = json.loads(request.forms.get('groups'))

    if not bins:
        return

    # take care of the SVG.
    svg_output_path = os.path.join(runinfo_dict['output_dir'], 'BINS.svg')
    print '* Storing SVG data into "%s"' % svg_output_path
    svg_output = open(svg_output_path, 'w')
    svg_output.write(base64.b64decode(request.forms.get('svg')))
    svg_output.close()
    runinfo_dict['bins_svg'] = svg_output_path

    # take care of bins.. start by removing the bins dir if it exists.
    bins_dir = os.path.join(runinfo_dict['output_dir'], 'BINS')
    if os.path.exists(bins_dir):
        shutil.rmtree(bins_dir)
    os.makedirs(bins_dir)
    runinfo_dict['bins'] = {} 
    print '* Storing bins under "%s"' % bins_dir
    for bin in bins:
        output_path = os.path.join(runinfo_dict['output_dir'], 'BINS', bin + '.fa')
        output = open(output_path, 'w')
        for contig in bins[bin]:
            output.write('>%s\n%s\n' % (contig, contigs[contig]))
        output.close()
        runinfo_dict['bins'][bin] = output_path

    # update RUNINFO dict...
    print '* Updating "%s"' % args.runinfo_dict
    cPickle.dump(runinfo_dict, open(args.runinfo_dict, 'w'))
    print


# increase maximum size of form data to 100 MB
BaseRequest.MEMFILE_MAX = 1024 * 1024 * 100 
webbrowser.open_new("http://127.0.0.1:%d" % args.port_number)
run(host='127.0.0.1', port=args.port_number, quiet=True)


