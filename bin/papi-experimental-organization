#!/usr/bin/env python
# -*- coding: utf-8

# Copyright (C) 2014, A. Murat Eren
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# Please read the COPYING file.

import sys
import argparse
import numpy as np
import hcluster

import PaPi.utils as utils
import PaPi.terminal as terminal
import PaPi.confighandler as confighandler
from PaPi.utils import ConfigError
from PaPi.filesnpaths import FilesNPathsError

progress = terminal.Progress()

parser = argparse.ArgumentParser(description='why yes we do stuff here.')
parser.add_argument('config_file', metavar = 'PATH', default = None, type=str,
                    help = 'Config file for clustering of contigs. See XXX for help.')
parser.add_argument('-i', '--input-directory', metavar = 'PATH', default = None, type=str,
                    help = 'Input directory to find matrix files')
parser.add_argument('-D', '--dry-run', default = False, action = 'store_true', 
                    help = 'Do not do anything, just print out the configuration.')

args = parser.parse_args()

try:
    config = confighandler.ClusteringConfiguration(args.config_file, args.input_directory)
except ConfigError, e:
    print e
    sys.exit(-1)
except FilesNPathsError, e:
    print e
    sys.exit(-2)

# FIXME: This should take a Run argument.
config.print_summary()

if args.dry_run:
    sys.exit()

def order_contigs(config, progress = terminal.Progress(verbose=False), run = terminal.Run()):
    if not config.multiple_matrices:
        # there is one matrix. could be coverage, could be tnf. we don't care.
        # we do what we gotta do: perform clustering based on the matrix, and
        # skip scaling.
        matrix_name = config.matrices[0]
        matrix_path = config.matrices_dict[matrix_name]['path']
        matrix_alias = config.matrices_dict[matrix_name]['alias']
        fields_to_return = config.matrices_dict[matrix_name]['columns_to_use']
        progress.new('Ordering contigs based on %s' % matrix_alias)
        progress.update('Reading input "%s"' % matrix_name)
        id_to_contig, header, vectors = utils.get_vectors_from_TAB_delim_matrix(matrix_path, fields_to_return)

        progress.update('Cluster analysis ...')
        tree = utils.get_clustering_as_tree(vectors, progress = progress)
        newick = utils.get_tree_object_in_newick(tree, id_to_contig)

        open(config.output_file_path, 'w').write(newick + '\n')
        run.info("Tree is stored", config.output_file_path)

    else:
        # ok. there is more than one matrix, so there will be a mixture of scaled vectors prior to clustering.
        # FIXME: this part needs to be parallelized.

        # determine whether ratios were set.
        ratios_set = True if config.matrices_dict[config.matrices[0]]['ratio'] else False

        # if ratios are not set there are two things that can be done; all components would be equally
        # distributed across matrices, or a heuristic that considers the number of samples in the experiment
        # and/or other experiment-specific properties to determine what could be a smart way to set ratios
        # for now, I will set them to one, but will put here a FIXME to remember coming back to the heuristic.
        # (on the other hand, maybe this is not the right place to do it and the caller of this func should
        # take care of it, we'll see).
        if not ratios_set:
            for matrix in config.matrices:
                config.matrices_dict[matrix]['ratio'] = 1


        # find out about the distribution of components across matrices.
        # note here we introduce a new member that was not in the original config class:
        # num_components per matrix.
        denominator = float(sum([r['ratio'] for r in config.matrices_dict.values()]))
        for matrix in config.matrices:
            m = config.matrices_dict[matrix]
            num_components_for_ratio = int(round(config.num_components * (m['ratio'] / denominator)))
            print num_components_for_ratio
            m['num_components'] = num_components_for_ratio


        # the rest of this code is un-constructed dream space. don't go there just yet.
        sys.exit()
        
        # working on TNF matrix
        scaled_tnf_vectors = utils.get_scaled_vectors(tnf_vectors, user_seed = args.seed, progress=progress)
        progress.end()
        #tnf_newick = cluster_combined_scaled_vectors(tnf_ids, scaled_tnf_vectors)
        
        # working on Coverage matrix
        progress.new('Coverage matrix')
        progress.update('Reading input')
        cov_ids_to_sample, cov_header, cov_vectors = utils.get_vectors_from_TAB_delim_matrix(args.input_coverage, only_essential_fields = True)
        cov_sample_to_id = dict([(v, k) for k, v in cov_ids_to_sample.iteritems()])
        scaled_cov_vectors = utils.get_scaled_vectors(cov_vectors, user_seed = args.seed, progress=progress)
        progress.end()
        #cov_newick = cluster_combined_scaled_vectors(cov_ids, scaled_cov_vectors)
        
        # update vectors
        progress.new('Final pass')
        progress.update('Normalizing scaled vectors')
        cov_vectors = utils.get_normalized_vectors(scaled_cov_vectors)
        tnf_vectors = utils.get_normalized_vectors(scaled_tnf_vectors)
        
        progress.update('Combining scaled vectors')
        combined_id_to_sample_dict = {}
        combined_scaled_vectors = []
        for i in range(0, len(tnf_ids)):
            combined_id_to_sample_dict[i] = tnf_ids[i]
            combined_vector = np.concatenate((tnf_vectors[i], cov_vectors[cov_sample_to_id[tnf_ids[i]]]), axis=0)
            combined_scaled_vectors.append(combined_vector)
        progress.end()
        
        progress.update('Cluster analysis')
        tree = utils.get_clustering_as_tree(combined_scaled_vectors, progress = progress)
        newick = utils.get_tree_object_in_newick(tree, combined_id_to_sample_dict)
        print newick

order_contigs(config)