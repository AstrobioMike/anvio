#!/usr/bin/env python
# -*- coding: utf-8
"""Return frequencies of amino acids in a gene

   Takes a bunch of BAM files, and a unique gene caller ID to count
   AA linkmer frequencies"""

import sys
import pandas as pd

from itertools import combinations
from numpy import exp, log as natural_log
from collections import Counter, OrderedDict

import anvio
import anvio.tables as t
import anvio.dbops as dbops
import anvio.utils as utils
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.filesnpaths as filesnpaths

from anvio.dbops import ContigsSuperclass
from anvio.constants import ribosomal_protein_kofams
from anvio.errors import ConfigError, FilesNPathsError


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2018, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['meren']
__requires__ = ['contigs-db']
__provides__ = ['codon-frequencies-txt', 'aa-frequencies-txt',]
__description__ = ("Get amino acid or codon frequencies of genes in a contigs database")


class ReportCodonFrequencies:
    def __init__(self, args, run=terminal.Run(), progress=terminal.Progress()):
        self.args = args
        self.run = run
        self.progress = progress

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.bam_file_path = A('bam_file')
        self.gene_caller_id = A('gene_caller_id')
        self.return_AA_frequencies_instead = A('return_AA_frequencies_instead')
        self.percent_normalize = A('percent_normalize')
        self.merens_codon_normalization = A('merens_codon_normalization')
        self.collapse_genes = A('collapse_genes')
        self.codon_usage_bias = A('codon_usage_bias')
        self.kofam_groups = A('kofam_groups')
        self.omnibias = A('omnibias')
        self.min_codon_count = A('min_codon_count')
        self.output_file_path = A('output_file')

        filesnpaths.is_output_file_writable(self.output_file_path)

        if self.merens_codon_normalization and self.percent_normalize:
            raise ConfigError("You can't use both `--merens-codon-normalization` and `--percent-normalize`. Please "
                              "read the help menu and pick one (you will get bonus points if you pick meren's "
                              "normalization because why not)")

        if self.merens_codon_normalization and self.return_AA_frequencies_instead:
            raise ConfigError("The flag `--merens-codon-normalization` is only relevant if you are working with codon "
                              "frequencies :/")

        if self.codon_usage_bias and (self.return_AA_frequencies_instead or self.percent_normalize
                                      or self.merens_codon_normalization or self.collapse_genes
                                      or self.gene_caller_id):
                raise ConfigError("You can't use `--codon-usage-bias` with codon/AA frequency options "
                                  "or a single gene caller ID:/")

        if (self.kofam_groups or self.omnibias) and not self.codon_usage_bias:
            raise ConfigError("The options `kofam-groups` and `omnibias` are only relevant "
                              "if you are working with codon usage bias :/")

        self.c = ContigsSuperclass(args)

        self.gene_caller_ids = set([])
        if self.gene_caller_id:
            if self.gene_caller_id not in self.c.genes_in_contigs_dict:
                raise ConfigError("Your contigs database named '%s' does not know anything about the gene caller id "
                                  "'%s' :/" % (self.c.a_meta['project_name'], str(self.gene_caller_id)))
            else:
                self.gene_caller_ids = [self.gene_caller_id]
        else:
            self.gene_caller_ids = set(self.c.genes_in_contigs_dict.keys())

        if self.return_AA_frequencies_instead:
            self.items = sorted(list(set(constants.codon_to_AA.values())))
        else:
            self.items = []
            for amino_acid in constants.AA_to_codons:
                self.items.extend(constants.AA_to_codons[amino_acid])

        self.item_name_conversion_dict = None

        if self.codon_usage_bias:
            module_hash = self.c.a_meta['modules_db_hash']
            if not module_hash:
                raise ConfigError("Your contigs database named '%s' has not been annotated by KEGG KOfams. "
                                  "Please run anvi-run-kegg-kofams on it :/" % self.c.a_meta['project_name'])

        self.process()


    def process(self):
        if self.gene_caller_id:
            self.c.init_contig_sequences(gene_caller_ids_of_interest=self.gene_caller_ids)
        elif self.codon_usage_bias:
            self.select_kofam_data()
            if self.kofam_groups:
                self.gene_caller_ids = set(self.gene_kofam_dict)
            try:
                self.c.init_contig_sequences(gene_caller_ids_of_interest=self.gene_caller_ids)
            except ConfigError as err:
                if self.kofam_groups:
                    raise ConfigError("No genes annotated with the requested KOfams were found in the contigs database :(")
                else:
                    raise err
        else:
            self.c.init_contig_sequences()

        noncoding_genes_skipped = set([])
        residue_frequencies = {}
        if self.collapse_genes:
            residue_frequencies['all'] = Counter()

        F = utils.get_list_of_AAs_for_gene_call if self.return_AA_frequencies_instead else utils.get_list_of_codons_for_gene_call

        for gene_caller_id in self.gene_caller_ids:
            gene_call = self.c.genes_in_contigs_dict[gene_caller_id]

            if gene_call['call_type'] != constants.gene_call_types['CODING']:
                noncoding_genes_skipped.add(gene_caller_id)
                continue

            gene_counts = Counter(F(gene_call, self.c.contig_sequences))
            if self.collapse_genes:
                residue_frequencies['all'] += gene_counts
            elif self.codon_usage_bias:
                if self.kofam_groups: # gene groups compared to each other or ribosomal protein ref
                    for kofam in self.gene_kofam_dict[gene_caller_id]:
                        for group_index, group in enumerate(self.kofam_group_dict[kofam]):
                            if group_index > 0:
                                gene_counts = Counter(F(gene_call, self.c.contig_sequences))
                            try:
                                residue_frequencies[group] += gene_counts
                            except KeyError:
                                residue_frequencies[group] = gene_counts
                elif self.omnibias: # all genes compared
                    residue_frequencies[gene_caller_id] = gene_counts
                else: # genes compared to ribosomal protein ref
                    if gene_caller_id in self.gene_kofam_dict: # ref ribosomal proteins
                        try:
                            residue_frequencies[-1] += gene_counts
                        except KeyError:
                            residue_frequencies[-1] = gene_counts
                    residue_frequencies[gene_caller_id] = gene_counts
            else:
                residue_frequencies[gene_caller_id] = gene_counts

        # Remove single codon amino acids for CUB
        ignored_codons_in_cub = constants.AA_to_codons['Met'] + constants.AA_to_codons['Trp'] + constants.AA_to_codons['STP']
        for gene_counts in residue_frequencies.values():
            for ignored_codon in ignored_codons_in_cub:
                try:
                    gene_counts.pop(ignored_codon)
                except KeyError:
                    pass

        if self.percent_normalize:
            for gene_caller_id in residue_frequencies:
                total = sum(residue_frequencies[gene_caller_id].values())
                residue_frequencies[gene_caller_id] = Counter(dict([(r, round(residue_frequencies[gene_caller_id][r] * 100.0 / total, 3)) \
                                                                                    for r in residue_frequencies[gene_caller_id]]))
        elif self.merens_codon_normalization:
            codons_used = set([])
            for gene_caller_id in residue_frequencies:
                for amino_acid in constants.AA_to_codons:
                    codons_of_interest = constants.AA_to_codons[amino_acid]
                    codons_of_interest_total = sum([residue_frequencies[gene_caller_id][r] for r in constants.AA_to_codons[amino_acid]])

                    for codon in codons_of_interest:
                        codons_used.add(codon)
                        if codons_of_interest_total:
                            residue_frequencies[gene_caller_id][codon] = round(residue_frequencies[gene_caller_id][codon] * 100.0 / codons_of_interest_total, 3)

            self.item_name_conversion_dict = dict([(codon, '%s-%s' % (constants.codon_to_AA[codon], codon)) for codon in codons_used])
        elif self.codon_usage_bias:
            synonymous_codon_groups = {aa: codons for aa, codons in constants.AA_to_codons.items() if len(codons) > 1} # exclude Met and Trp

            relative_frequencies = OrderedDict()
            short_codon_sets = []
            codon_set_ids_to_remove = []
            for codon_set_id, codon_counts in residue_frequencies.items():
                if sum(codon_counts.values()) < self.min_codon_count:
                    short_codon_sets.append(codon_set_id)
                    codon_set_ids_to_remove.append(codon_set_id)
                    continue
                relative_frequencies[codon_set_id] = synonymous_frequencies = {}
                for amino_acid, synonymous_codons in synonymous_codon_groups.items():
                    total_aa_codon_count = sum([codon_counts[codon] for codon in synonymous_codons])
                    for codon in synonymous_codons:
                        if total_aa_codon_count:
                            synonymous_frequencies[codon] = codon_counts[codon] / total_aa_codon_count
                        else:
                            synonymous_frequencies[codon] = -1
            for codon_set_id in codon_set_ids_to_remove:
                residue_frequencies.pop(codon_set_id)

            cub_dict = OrderedDict()
            if self.omnibias:
                missing_amino_acids = Counter()
                comparisons = combinations(relative_frequencies, 2)
                for codon_set_id in relative_frequencies:
                    cub_dict[codon_set_id] = OrderedDict()

                if self.codon_usage_bias == 'cai':
                    all_ref_weights = {}
                    for codon_set_id, ref_synonymous_frequencies in relative_frequencies:
                        all_ref_weights[codon_set_id] = ref_weights = {}
                        for amino_acid, synonymous_codons in synonymous_codon_groups:
                            max_synonymous_frequency = max([ref_synonymous_frequencies[codon] for codon in synonymous_codons])
                            if max_synonymous_frequency == -1: # no codons for AA in ribosomal proteins
                                missing_amino_acids[amino_acid] += 1
                                continue

                            for codon in synonymous_codon_groups[amino_acid]:
                                ref_weights[codon] = natural_log(ref_synonymous_frequencies[codon] / max_synonymous_frequency)

                    for codon_set_id, ref_codon_set_id in comparisons:
                        cub_subdict = cub_dict[codon_set_id]
                        codon_counts = residue_frequencies[codon_set_id]
                        sum_weighted_counts = 0
                        for amino_acid, log_weight in all_ref_weights[ref_codon_set_id].items():
                            for codon in synonymous_codon_groups[amino_acid]:
                                sum_weighted_counts += codon_counts[codon] * log_weight
                        cub_subdict[ref_codon_set_id] = exp(sum_weighted_counts / sum(codon_counts.values()))
                elif self.codon_usage_bias == 'delta':
                    for codon_set_id, ref_codon_set_id in comparisons:
                        cub_subdict = cub_dict[codon_set_id]
                        codon_counts = residue_frequencies[codon_set_id]
                        query_synonymous_frequencies = relative_frequencies[codon_set_id]
                        ref_synonymous_frequencies = relative_frequencies[ref_codon_set_id]
                        sum_weighted_counts = 0
                        skipped_codon_count = 0
                        for codon, codon_count in codon_counts.items():
                            query_synonymous_frequency = query_synonymous_frequencies[codon]
                            ref_synonymous_frequency = ref_synonymous_frequencies[codon]
                            if query_synonymous_frequency == -1 or ref_synonymous_frequency <= 0:
                                # A value of -1 means a missing amino acid in one codon set of the other
                                # A value of 0 in the reference means a missing codon
                                skipped_codon_count += codon_count
                                continue
                            sum_weighted_counts += codon_count * natural_log(query_synonymous_frequency / ref_synonymous_frequency)
                        retained_codon_count = (sum(codon_counts.values()) - skipped_codon_count)
                        if retained_codon_count < self.min_codon_count:
                            short_codon_sets.append(codon_set_id)
                            continue
                        cub_subdict[codon_set_id] = sum_weighted_counts / retained_codon_count
            else: # ribosomal protein ref
                ref_synonymous_frequencies = relative_frequencies[-1]
                missing_amino_acids = [] # in the ref set

                if self.codon_usage_bias == 'cai':
                    ref_weights = {}
                    for amino_acid, synonymous_codons in synonymous_codon_groups:
                        max_synonymous_frequency = max([ref_synonymous_frequencies[codon] for codon in synonymous_codons])
                        if max_synonymous_frequency == -1: # no codons for AA in ribosomal proteins
                            missing_amino_acids.append(amino_acid)
                            continue

                        for codon in synonymous_codon_groups[amino_acid]:
                            ref_weights[codon] = natural_log(ref_synonymous_frequencies[codon] / max_synonymous_frequency)

                    residue_frequencies.pop(-1) # remove ribosomal protein ref from "queries"
                    for codon_set_id, codon_counts in residue_frequencies.items():
                        sum_weighted_counts = 0
                        for amino_acid, log_weight in ref_weights.items():
                            for codon in synonymous_codon_groups[amino_acid]:
                                sum_weighted_counts += codon_counts[codon] * log_weight
                        cub_dict[codon_set_id] = exp(sum_weighted_counts / sum(codon_counts.values()))
                elif self.codon_usage_bias == 'delta':
                    residue_frequencies.pop(-1) # remove ribosomal protein ref from "queries"
                    for codon_set_id, codon_counts in residue_frequencies.items():
                        query_synonymous_frequencies = relative_frequencies[codon_set_id]
                        sum_weighted_counts = 0
                        skipped_codon_count = 0
                        for codon, codon_count in codon_counts.items():
                            query_synonymous_frequency = query_synonymous_frequencies[codon]
                            ref_synonymous_frequency = ref_synonymous_frequencies[codon]
                            if query_synonymous_frequency == -1 or ref_synonymous_frequency <= 0: # missing amino acid in one codon set of the other
                                # A value of -1 means a missing amino acid in one codon set of the other
                                # A value of 0 in the reference means a missing codon
                                skipped_codon_count += codon_count
                                continue
                            sum_weighted_counts += codon_count * natural_log(query_synonymous_frequency / ref_synonymous_frequency)
                        retained_codon_count = (sum(codon_counts.values()) - skipped_codon_count)
                        if retained_codon_count < self.min_codon_count:
                            short_codon_sets.append(codon_set_id)
                            continue
                        cub_dict[codon_set_id] = sum_weighted_counts / retained_codon_count


        if len(noncoding_genes_skipped):
            self.run.warning(f"{len(noncoding_genes_skipped)} of {len(self.gene_caller_ids)} "
                             f"{'gene_groups' if self.kofam_groups else 'genes'} were skipped "
                             "and will not be in the final report since they were 'noncoding' gene calls.")

        if not len(residue_frequencies):
            raise ConfigError("Anvi'o has no residue frequencies to work with :(")

        if self.codon_usage_bias:
            if short_codon_sets:
                self.run.warning(f"{len(short_codon_sets)} of {len(self.gene_caller_ids)} "
                                 f"{'gene_groups' if self.kofam_groups else 'genes'} did not have "
                                 f"more than the minimum {self.min_codon_count} codons required to calculate CUB.")
            if self.omnibias:
                if missing_amino_acids:
                    self.run.warning("The following amino acids were not observed in the given numbers of"
                                     f"{'gene groups' if self.kofam_groups else 'genes'}: "
                                     f"{', '.join(sorted([amino_acid + ' ' + str(count) for amino_acid, count in missing_amino_acids.items()]))}")
                row_count = len(cub_dict)
                cub_rows = []
                for cub_subdict in cub_dict.values():
                    cub_rows.append([None for _ in range(row_count - len(cub_subdict))]
                                    + [cub for cub in cub_subdict.values()])
                cub_df = pd.DataFrame(cub_rows, index=cub_dict, columns=cub_dict)
                cub_df.to_csv(self.output_file_path, sep='\t')
            else: # ribosomal protein ref
                if missing_amino_acids:
                    self.run.warning("The following amino acids were not observed in ribosomal proteins annotated by KOfams: "
                                     f"{', '.join(missing_amino_acids)}")
                first_col_header = 'kofam_group' if self.kofam_groups else 'gene_id'
                cub_df = pd.DataFrame(zip(cub_dict, cub_dict.values()),
                                      columns=[first_col_header, self.codon_usage_bias])
                cub_df[self.codon_usage_bias] = cub_df[self.codon_usage_bias].round(5)
                cub_df.to_csv(self.output_file_path, sep='\t', index=False)
        else:
            utils.store_dict_as_TAB_delimited_file(residue_frequencies,
                                                   self.output_file_path,
                                                   headers=['gene_callers_id'] + self.items,
                                                   header_item_conversion_dict=self.item_name_conversion_dict)

        self.run.info('Output file', self.output_file_path)


    def select_kofam_data(self):
        """
        Gather info on KOfam annotated genes used in CUB calculations.
        If KOfam groups were supplied, select genes assigned to these KOfams.
        If not in omnibias mode, select genes assigned to ribosomal protein KOfams.
        """

        contigs_db = dbops.ContigsDatabase(self.c.contigs_db_path)
        kegg_df = contigs_db.db.get_table_as_dataframe(t.gene_function_calls_table_name)
        contigs_db.disconnect()
        kegg_df = kegg_df[kegg_df['source'] == 'KOfam']

        self.gene_kofam_dict = gene_kofam_dict = OrderedDict()
        self.kofam_group_dict = kofam_group_dict = OrderedDict()

        gene_ids = []
        kofams = []

        if self.kofam_groups:
            try:
                filesnpaths.is_file_exists(self.kofam_groups)
            except:
                raise ConfigError("The file of KOfam group definitions named '%s' does not exist :/" % self.kofam_groups)

            kofam_group_df = pd.read_csv(self.kofam_groups, sep='\t', header=None, names=['kofam', 'funcgroup'], dtype=str)
            for kofam, funcgroup in zip(kofam_group_df['kofam'], kofam_group_df['funcgroup']):
                try:
                    kofam_group_dict[kofam].append(funcgroup)
                except KeyError:
                    kofam_group_dict[kofam] = [funcgroup]

            kegg_select_df = kegg_df[kegg_df['accession'].isin(kofam_group_dict)]
            gene_ids.extend(kegg_select_df['gene_callers_id'])
            kofams.extend(kegg_select_df['accession'])

        if not self.omnibias: # ribosomal protein ref
            for kofam in ribosomal_protein_kofams:
                try:
                    kofam_group_dict[kofam].append(-1)
                except KeyError:
                    kofam_group_dict[kofam] = [-1]

            kegg_select_df = kegg_df[kegg_df['accession'].isin(ribosomal_protein_kofams)]

            if len(kegg_select_df) == 0:
                raise ConfigError("No genes annotated by reference ribosomal protein KOfams were found in the contigs database :/")

            gene_ids.extend(kegg_select_df['gene_callers_id'])
            kofams.extend(kegg_select_df['accession'])

        for gene_id, kofam in zip(gene_ids, kofams):
            try:
                gene_kofam_dict[gene_id].add(kofam)
            except KeyError:
                gene_kofam_dict[gene_id] = set([kofam])


if __name__ == '__main__':
    from anvio.argparse import ArgumentParser

    parser = ArgumentParser(description=__description__)

    groupA = parser.add_argument_group('INPUT DATABASE', 'The contigs database. Clearly those genes must be read from somewhere.')
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db'))

    groupC = parser.add_argument_group('OPTIONALS', "Important things to read never end. Stupid science.")
    groupC.add_argument(*anvio.A('gene-caller-id'), **anvio.K('gene-caller-id', {'help': "OK. You can declare a single gene caller ID if you wish, in\
                                                                which case anvi'o would only return results for a single gene call. If you don't declare\
                                                                anything, well, you must be prepared to brace yourself if you are working with a very\
                                                                large contigs database with hundreds of thousands of genes."}))
    groupC.add_argument('--collapse-genes', default=False, action="store_true", help="By default, codon frequencies are reported on a per-gene basis, meaning "
                                                                                     "that a frequency is reported for each gene-codon pairing. If you provide "
                                                                                     "this flag, codon frequencies will instead be collapsed across genes, "
                                                                                     "such that a single frequency is reported for each codon.")

    groupC.add_argument(*anvio.A('return-AA-frequencies-instead'), **anvio.K('return-AA-frequencies-instead'))
    groupC.add_argument(*anvio.A('output-file'), **anvio.K('output-file', {'required': True}))


    groupC.add_argument('--percent-normalize', default=False, action="store_true", help = "Instead of actual counts, report percent-normalized\
                                                                frequencies per gene (because you are too lazy to do things the proper way in R).")
    groupC.add_argument('--merens-codon-normalization', default=False, action="store_true", help = "This is a flag to percent normalize codon frequenies within those\
                                                                that encode for the same amino acid. It is different from the flag --percent-normalize, since it\
                                                                does not percent normalize frequencies of codons within a gene based on all codon frequencies. Clearly\
                                                                this flag is not applicable if you wish to work with boring amino acids. WHO WORKS WITH AMINO ACIDS\
                                                                ANYWAYS.")

    groupC.add_argument('--codon-usage-bias', choices=['cai', 'delta'], help="Report a single codon usage bias metric instead of absolute or relative codon frequencies.\
                                                                              The chosen metric may require a reference sequence set, which by default is the set of\
                                                                              ribosomal proteins predicted by KEGG KOfams. So don't be surprised by an angry error\
                                                                              that you need to run `anvi-run-kegg-kofams` on your contigs database.\
                                                                              CAI is the codon adaptation index of Sharp and Li (1987).\
                                                                              Delta is the likelihood ratio of Ran and Higgs (2012) Eq. (5),\
                                                                              with the null reference codon set being the ribosomal proteins by default\
                                                                              or each other codon set when the `--omnibias` flag is used.")
    groupC.add_argument('--kofam-groups', help="Rather than reporting a codon usage metric per gene, report CUB from sets of genes defined by KEGG KOfams.\
                                                For example, you may wish to compare the overall CUB of genes in different KEGG modules to the ribosomal protein reference.\
                                                Provide a tab-delimited text file with two columns (no header). In the first column is a list of KOfam IDs\
                                                and in the second is a list of group names, e.g., KEGG module IDs or group names/IDs that you invent.\
                                                A KOfam ID may be in more than one row, since a gene may be part of multiple groups.")
    groupC.add_argument('--omnibias', default=False, action="store_true", help="Rather than calculating codon usage bias against the default reference of ribosomal proteins,\
                                                                                calculate CUB of every gene or group of genes against every other gene or group of genes,\
                                                                                producing a diagonal matrix of CUB values for every combination. A warning will be raised\
                                                                                suggesting that you abort mission if you have not used `--kofam-groups`,\
                                                                                since comparing the codon usage of every gene seems pretty weird.")
    groupC.add_argument('--min-codon-count', default=100, type=int, help="Do not calculate codon usage bias for genes (or groups of genes) with fewer than this number of codons\
                                                                          in the gene after also subtracting the number of ignored codons. Ignored codons cannot be compared\
                                                                          to the reference as it would involve dividing by or taking the log of zero in the statistic.")

    args = parser.get_args(parser)

    try:
        ReportCodonFrequencies(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
