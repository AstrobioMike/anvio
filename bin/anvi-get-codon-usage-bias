#!/usr/bin/env python
# -*- coding: utf-8
"""Get codon usage bias (CUB) of genes and functions."""


import os
import sys
import pandas as pd

import anvio
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.codonusage as codonusage
import anvio.filesnpaths as filesnpaths

from anvio.argparse import ArgumentParser
from anvio.errors import ConfigError, FilesNPathsError


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2022, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['semiller10']
__requires__ = ['contigs-db',
                'profile-db',
                'collection',
                'bin',
                'internal-genomes',
                'external-genomes']
__provides__ = []
__description__ = ("Get codon usage bias (CUB) statistics of genes and functions.")


run = terminal.Run()


def main(args):
    """Prepare arguments to get codon usage bias."""

    if not args.output_file:
        raise ConfigError("`--output-file` must be provided.")
    filesnpaths.is_output_file_writable(args.output_file, ok_if_exists=False)

    if args.function_sources is None:
        from_function_sources = False
    elif len(args.function_sources) != 1 and (args.function_accessions or args.function_names):
        raise ConfigError(
            "`--function-accessions` and `--function-names` require a single value for "
            "`--function-sources`. If select functions come from more than one source, use "
            "`--select-functions-txt`.")
    elif len(args.function_sources) == 0:
        from_function_sources = True
    else:
        from_function_sources = args.function_sources

    if (args.function_accessions or args.function_names) and args.select_functions_txt:
        raise ConfigError("`--function-accessions` or `--function-names` should not be used with "
                          "`args.select_functions_txt`.")

    # Select function sources and functions of interest.
    args.function_accessions_dict = {}
    args.function_names_dict = {}
    if isinstance(from_function_sources, list):
        function_source = from_function_sources[0]
        function_accessions = args.function_accessions if args.function_accessions else []
        for function_accession in function_accessions:
            try:
                args.function_accessions_dict[function_source].append(function_accession)
            except KeyError:
                args.function_accessions_dict[function_source] = [function_accession]
        function_names = args.function_names if args.function_names else []
        for function_name in function_names:
            try:
                args.function_names_dict[function_source].append(function_name)
            except KeyError:
                args.function_names_dict[function_source] = [function_name]

    parse_select_functions_table(args)

    if args.include_amino_acids and args.exclude_amino_acids:
        raise ConfigError(
            "Either `--include-amino-acids` or `--exclude-amino-acids` should be given, not both.")

    if ((args.reference_function_accessions or args.reference_function_names)
        and args.select_reference_functions_txt):
        raise ConfigError("`--reference-function-accessions` and `--reference-function-names "
                          "should not be used with `--select-reference-functions-txt`.")

    # Select reference functions of interest.
    args.reference_function_accessions_dict = {}
    args.reference_function_names_dict = {}
    reference_function_accessions = \
        args.reference_function_accessions if args.reference_function_accessions else []
    for function_accession in reference_function_accessions:
        try:
            args.reference_function_accessions_dict[args.reference_function_source].append(function_accession)
        except KeyError:
            args.reference_function_accessions_dict[args.reference_function_source] = [function_accession]
    reference_function_names = \
        args.reference_function_names if args.reference_function_names else []
    for function_name in reference_function_names:
        try:
            args.reference_function_names_dict[args.reference_function_source].append(function_name)
        except KeyError:
            args.reference_function_names_dict[args.reference_function_source] = [function_name]

    parse_select_reference_functions_table(args)

    # Amino acids to exclude are the complement of amino acids to include.
    if args.include_amino_acids:
        args.exclude_amino_acids = []
        for amino_acid in constants.amino_acids:
            if amino_acid in args.include_amino_acids:
                continue
            else:
                args.exclude_amino_acids.append(amino_acid)

    # Get CUB tables. Separate tables are produced for each combination of input genome and CUB
    # metric.
    if args.internal_genomes or args.external_genomes:
        multigenome_codon_usage = codonusage.MultiGenomeCodonUsage(args, run=run)
        # The outer keys are genome names and the inner keys are CUB metrics in the returned dict.
        cub_table_dict = multigenome_codon_usage.get_codon_usage_bias(
            metrics=args.metrics,
            from_function_sources=from_function_sources,
            function_accessions=args.function_accessions_dict,
            function_names=args.function_names_dict,
            expect_functions=args.expect_functions,
            omnibias=args.omnibias,
            reference_function_accessions=args.reference_function_accessions,
            reference_function_names=args.reference_function_names,
            expect_reference_functions=args.expect_reference_functions,
            gene_min_codons=args.gene_min_codons,
            function_min_codons=args.function_min_codons,
            min_codon_filter=args.min_codon_filter,
            drop_amino_acids=args.exclude_amino_acids,
            min_amino_acids=args.exclude_amino_acid_count,
            min_gene_fraction=args.exclude_amino_acid_fraction,
            query_min_analyzed_codons=args.query_min_analyzed_codons,
            reference_exclude_amino_acid_count=args.reference_exclude_amino_acid_count,
            reference_min_codons=args.reference_min_codons)
    else:
        single_genome_codon_usage = codonusage.SingleGenomeCodonUsage(args, run=run)
        # The keys are CUB metrics in the returned dict.
        cub_table_dict = single_genome_codon_usage.get_codon_usage_bias(
            metrics=args.metrics,
            from_function_sources=from_function_sources,
            gene_caller_ids=args.gene_caller_ids,
            function_accessions=args.function_accessions_dict,
            function_names=args.function_names_dict,
            expect_functions=args.expect_functions,
            omnibias=args.omnibias,
            reference_gene_caller_ids=args.reference_gene_caller_ids,
            reference_function_accessions=args.reference_function_accessions,
            reference_function_names=args.reference_function_names,
            expect_reference_functions=args.expect_reference_functions,
            gene_min_codons=args.gene_min_codons,
            function_min_codons=args.function_min_codons,
            min_codon_filter=args.min_codon_filter,
            drop_amino_acids=args.exclude_amino_acids,
            min_amino_acids=args.exclude_amino_acid_count,
            min_gene_fraction=args.exclude_amino_acid_fraction,
            query_min_analyzed_codons=args.query_min_analyzed_codons,
            reference_exclude_amino_acid_count=args.reference_exclude_amino_acid_count,
            reference_min_codons=args.reference_min_codons)

    # Write output tables.
    if args.internal_genomes or args.external_genomes:
        # Multiple genomes.
        output_file_root, output_file_extension = os.path.splitext(args.output_file)
        output_paths = []
        if args.omnibias:
            # Output an omnibias CUB table for each genome + metric.
            for genome_name, inner_dict in cub_table_dict.items():
                for metric, cub_df in inner_dict.items():
                    output_path = os.path.join(
                        output_file_root + '-' + genome_name + '-' + metric, output_file_extension)
                    output_paths.append(output_path)
                    cub_df.to_csv(output_path, sep='\t')
        else:
            # Output a CUB table for each genome, with a column for each metric in the tables.
            for genome_name, inner_dict in cub_table_dict.items():
                cub_df = pd.concat(inner_dict.values(), axis=1)
                output_path = os.path.join(
                    output_file_root + '-' + genome_name, output_file_extension)
                output_paths.append(output_path)
                cub_df.to_csv(output_path, sep='\t')
        run.info("CUB table output directory", os.path.dirname(output_path))
        run.info("CUB table output files",
                 ', '.join([os.path.basename(output_path) for output_path in output_paths]))
    else:
        # Single genome, one or more CUB metrics.
        if args.omnibias:
            # Output an omnibias CUB table for each metric.
            output_paths = []
            for metric, cub_df in cub_table_dict.items():
                output_path = os.path.join(output_file_root + '-' + metric, output_file_extension)
                output_paths.append(output_path)
                cub_df.to_csv(output_path, sep='\t')
            run.info("CUB table output directory", os.path.dirname(output_path))
            run.info("CUB table output files",
                     ', '.join([os.path.basename(output_path) for output_path in output_paths]))
        else:
            # Output a single CUB table with a column for each metric.
            cub_df = pd.concat(cub_table_dict.values(), axis=1)
            cub_df.to_csv(args.output_file, sep='\t')
            run.info("CUB table output", args.output_file)


def parse_select_functions_table(args):
    """Select genes for the CUB analysis from functions specified in a tabular file."""
    if not args.select_functions_txt:
        return

    select_functions_df = pd.read_csv(
        args.select_functions_txt, sep='\t', header=None, columns=['source', 'accession', 'name'])
    select_functions_df = select_functions_df.fillna('')

    for row in select_functions_df.itertuples(index=False):
        if not row.source:
            raise ConfigError(
                "Each row of the select functions table must have a source entry, as functions are "
                "allowed to come from different function annotation sources.")

        if not row.accession and not row.name:
            raise ConfigError(
                "Each row of the select functions table must have either an accession or function "
                "entry to define the function being sought in the annotation source.")

        if row.source == 'KEGG_BRITE' and not row.name:
            raise ConfigError(
                "In the select functions table, KEGG BRITE categories must be named in the third "
                "column. Categories do not have accessions in most BRITE hierarchies, and "
                "hierarchy accessions are not useful here.")

        if row.accession:
            try:
                args.function_accessions_dict[row.source].append(row.accession)
            except KeyError:
                args.function_accessions_dict[row.source] = [row.accession]

        if row.name:
            try:
                args.function_names_dict[row.source].append(row.name)
            except KeyError:
                args.function_names_dict[row.source] = [row.name]


def parse_select_reference_functions_table(args):
    """Select reference genes for the CUB analysis from functions specified in a tabular file."""
    if not args.select_reference_functions_txt:
        return

    select_reference_functions_df = pd.read_csv(
        args.select_reference_functions_txt,
        sep='\t',
        header=None,
        columns=['source', 'accession', 'name'])
    select_reference_functions_df = select_reference_functions_df.fillna('')

    for row in select_reference_functions_df.itertuples(index=False):
        if not row.source:
            raise ConfigError(
                "Each row of the select reference functions table must have a source entry, as "
                "functions are allowed to come from different function annotation sources.")

        if not row.accession and not row.name:
            raise ConfigError(
                "Each row of the select reference functions table must have either an accession or "
                "function entry to define the function being sought in the annotation source.")

        if row.source == 'KEGG_BRITE' and not row.name:
            raise ConfigError(
                "In the select reerence functions table, KEGG BRITE categories must be named in "
                "the third column. Categories do not have accessions in most BRITE hierarchies, "
                "and hierarchy accessions are not useful here.")

        if row.accession:
            try:
                args.reference_function_accessions_dict[row.source].append(row.accession)
            except KeyError:
                args.reference_function_accessions_dict[row.source] = [row.accession]

        if row.name:
            try:
                args.reference_function_names_dict[row.source].append(row.name)
            except KeyError:
                args.reference_function_names_dict[row.source] = [row.name]


if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    groupA = parser.add_argument_group(
        'SINGLE GENOME INPUTS',
        "Get CUB of \"query\" genes or functions in a single genome. A contigs database can be "
        "provided alone as an \"external\" genome. An \"internal\" genome (bin) also requires a "
        "profile database, collection name, and bin ID.")
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db', {'required': False}))
    groupA.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    groupA.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    groupA.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    groupA.add_argument(
        '--gene-caller-ids', type=int, nargs='+', help="Return CUB for genes with these IDs.")

    groupB = parser.add_argument_group(
        'MULTIPLE GENOME INPUTS',
        "Get CUB from genes or functions in multiple genomes by providing internal and/or "
        "external genome files listing the genomes to analyze.")
    groupB.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))
    groupB.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))

    groupC = parser.add_argument_group('OUTPUT')
    groupC.add_argument(*anvio.A('output-file'), **anvio.K('output-file', {'help':
        "This program writes one or more tab-delimited files of gene/function CUB statistics. All "
        "tables have gene/function row labels. 1.a. Single genome, single CUB metric, not omnibias "
        "mode: A table with one column of CUB data is written to the provided output file path. "
        "1.b. Single genome, single CUB metric, omnibias mode: A table of gene/function x "
        "gene/function is written to the provided output file path. 2.a. Single genome, multiple "
        "CUB metrics, not omnibias mode: A table with a column of CUB data per metric is written "
        "to the provided output file path. 2.b. Single genome, multiple CUB metrics, omnibias "
        "mode: A table of gene/function x gene/function is written per CUB metric, with the output "
        "file path serving as a template for the per-metric file paths. 3.a. Multiple genomes, "
        "single CUB metric, not omnibias mode: A table with one column of CUB data is written per "
        "genome, with the output file path serving as a template for the per-genome file paths. "
        "3.b. Multiple genomes, single CUB metric, omnibias mode: A table of gene/function x "
        "gene/function is written per genome, with the output file path serving as a template for "
        "the per-genome file paths. 4.a. Multiple genomes, multiple CUB metrics, not omnibias "
        "mode: A table with a column of CUB data per metric is written per genome, with the output "
        "file path serving as a template for the per-genome file paths. 4.b. Multiple genomes, "
        "multiple CUB metrics, omnibias mode: A table of gene/function x gene/function is written "
        "per genome x CUB metric, with the output file path serving as a template for the "
        "per-genome x metric file paths."}))

    groupD = parser.add_argument_group('CUB_METRIC')
    groupD.add_argument(
        '--metrics', choices=['cai', 'delta'], nargs='*',
        help="These are the metrics used in CUB calculations, with a separate calculation and a "
             "separate section of rows in the output table for each metric provided. When used as "
             "a flag, `--metrics` returns every possible metric. Some CUB metrics depend on "
             "definition of a reference codon composition, whereas others are "
             "reference-independent. 'cai' is the reference-dependent Codon Adaptation Index of "
             "Sharp and Li (1987). 'delta' is a reference-dependent metric of Ran and Higgs (2012, "
             "Eq. 6) that involves the overall codon composition of the genome in the comparison.")

    groupE = parser.add_argument_group(
        'FUNCTION SELECTION',
        "Calculate CUB for functions rather than genes. The codon frequencies of genes annotated "
        "by a function are summed, treating functions as concatenations of genes, with longer "
        "genes contributing more than shorter genes to function codon usage. Alternative methods "
        "of combining gene codon frequencies, such as averaging genes, would not treat every gene "
        "equally. Averaging means that short genes have equal importance as long genes in the CUB "
        "of a function, which could imply that short genes are rate-limiting and therefore need to "
        "be favored for translation.")
    groupE.add_argument(
        '--function-sources', nargs='*',
        help="Return CUB for functions annotated by these sources, e.g., 'KOfam', 'KEGG_BRITE', "
             "'COG20_FUNCTION'. If `--function-sources` is used as a flag without any arguments, "
             "then every source will be considered.")
    groupE.add_argument(
        '--function-accessions', nargs='+',
        help="Return CUB for functions with these accessions from the source provided in "
             "`--function-sources`. To get accessions from multiple sources, instead use "
             "`--select-functions-txt`.")
    groupE.add_argument(
        '--function-names', nargs='+',
        help="Return CUB for functions with these names from the source provided in "
             "`--function-sources`. To get function names from multiple sources, instead "
             "use `--select-functions-txt`.")
    groupE.add_argument(
        '--select-functions-txt',
        help="Functions to select can be listed in this tab-delimited file of three columns. The "
             "first column should contain function annotation sources, the second column "
             "accessions, and the third function names. An entry in the source column is required "
             "in every row, and either an accession or name, or both, should also be in a row. "
             "Column names should not be provided.")
    groupE.add_argument(
        '--expect-functions',
        default=False,
        action='store_true',
        help="By default, functions provided by `--function-accessions`, `--function-names`, and "
             "`--select-functions-txt` need not be annotated in the input genomes. With this flag, "
             "an error will be raised if any of the functions are not present.")
    groupE.add_argument(
        '--shared-function-sources', default=False, action='store_true',
        help="When analyzing multiple genomes, exclude function annotation sources that were not "
             "run on every genome.")

    groupF = parser.add_argument_group(
        'REFERENCE',
        "Certain CUB metrics rely on definition of a reference codon composition. Often, a set of "
        "housekeeping genes including ribosomal proteins is used as the reference. The reference "
        "codon frequencies are the sums of the reference gene codon frequencies -- long genes "
        "contribute more to reference codon frequencies than short genes.")
    groupF.add_argument(
        '--omnibias', default=False, action='store_true',
        help="Use every gene or function as a separate reference rather than defining a set of "
             "reference genes or functions. The resulting table of gene x gene (or function x "
             "function) CUB values is like a distance matrix of the similarity of gene codon "
             "compositions.")
    groupF.add_argument(
        '--reference-gene-caller-ids', type=int, nargs='+',
        help="Select reference genes by ID, space-separated.")
    groupF.add_argument(
        '--reference-function-source', default='KEGG_BRITE',
        help="Use this function annotation source, e.g., 'KEGG_BRITE', 'KOfam', 'COG20_FUNCTION', "
             "when selecting reference functions by name or accession. By default, reference genes "
             "are ribosomal proteins as classified by KEGG BRITE, requiring input contigs "
             "databases to have been annotated by `anvi-run-kegg-kofams`.")
    groupF.add_argument(
        '--reference-function-accessions', nargs='+',
        help="Select reference genes annotated with these function accessions by "
             "`--reference-function-source`. To get accessions from multiple sources, instead use "
             "`--select-functions-txt`.")
    groupF.add_argument(
        '--reference-function-names', nargs='+', default=['Ribosome>>>Ribosomal proteins'],
        help="Select reference genes annotated with these function names by "
             "`--reference-function-source`. To get function names from multiple sources, instead "
             "use `--select-functions-txt`. By default, reference genes are ribosomal proteins as "
             "classified by KEGG BRITE, requiring input contigs databases to have been annotated "
             "by `anvi-run-kegg-kofams`.")
    groupF.add_argument(
        '--select-reference-functions-txt',
        help="Selected reference functions can be listed in this tab-delimited file of three "
             "columns. The first column should contain function annotation sources, the second "
             "column accessions, and the third function names. An entry in the source column is "
             "required in every row, and either an accession or name, or both, should also be in "
             "a row. The file should not have a header of column names.")
    groupF.add_argument(
        '--expect-reference-functions', default=False, action='store_true',
        help="By default, reference functions provided by `--reference-function-accessions`, "
             "`--reference-function-names`, and `--select-reference-functions-txt` need not all be "
             "annotated in the input genomes. For example, if two KEGG BRITE categories are used "
             "as references -- 'Ribosome>>>Ribosomal proteins>>>Bacteria' and "
             "'Transcription machinery>>>Prokaryotic type>>>Bacterial type>>>RNA polymerase' -- "
             "and no genes annotated by one of the categories, then reference genes will still be "
             "taken from the other category. If no genes are annotated by either category, an "
             "error will occur since at least one reference gene is needed. However, with this "
             "flag, an error will be raised if any of the reference functions are not present in "
             "an input genome.")

    groupG = parser.add_argument_group(
        'FILTER GENES, FUNCTIONS, CODONS',
        "Genes/functions can be filtered by the number of codons they contain, e.g., ignore genes "
        "shorter than 300 codons. Codons can be selected a priori, e.g., ignore Ala codons, or "
        "rarer codons can be excluded, e.g., ignore amino acids that are decoded by ≤3 codons in "
        "≥90%% of genes. Filters can improve the statistical utility of CUB data. These filters do "
        "not apply to the reference gene set.")
    groupG.add_argument(
        '--gene-min-codons', type=int, default=0,
        help="Set the minimum number of codons required in a gene. When functions are returned "
             "rather than genes, this filter is applied to genes before grouping them as "
             "functions.")
    groupG.add_argument(
        '--function-min-codons', type=int, default=0,
        help="Set the minimum number of codons required in a function. Genes with fewer than "
             "`--gene-min-codons` are first removed, and then functional groups of the remaining "
             "genes with fewer than `--function-min-codons` are removed. This filter only applies "
             "when returning function \"queries\".")
    groupG.add_argument(
        '--exclude-amino-acids', nargs='+', default=['STP'],
        help="Remove codons that decode the given amino acids (use three-letter codes, e.g., "
             "Ala). ")
    groupG.add_argument(
        '--include-amino-acids', nargs='+',
        help="This is the complement of `--exclude-amino-acids`. Only codons for the given amino "
             "acids are analyzed.")
    groupG.add_argument(
        '--exclude-amino-acid-count', type=int, default=0,
        help="Remove codons for amino acids (and STP) that are less numerous than the given "
             "argument in the fraction of genes given by `--exclude-amino-acid-fraction`. For "
             "example, say this argument is 3 and `--exclude-amino-acid-fraction` is 0.9: if there "
             "are fewer than 5 codons for an amino acid/STP in ≥90%% of genes, then the amino "
             "acid's codons are removed.")
    groupG.add_argument(
        '--min-codon-filter', choices=['length', 'remaining', 'both'], default='both',
        help="This argument arises from the ambiguity of filters that remove genes and functions "
             "by number of codons (`--gene-min-codons` and `--function-min-codons`) in relation to "
             "the filters that drop codons (`--exclude/include-amino-acids` and "
             "`--exclude-amino-acid-count/fraction`). Genes (and functions) can be filtered by "
             "their full length, e.g., genes shorter than 300 codons are ignored. They can also be "
             "filtered by the number of codons remaining after dropping codons. The codon length "
             "filter followed by dropping codons can result in genes and functions with fewer "
             "codons than the original codon threshold -- thus the option of both \"length\" and "
             "\"remaining\" filters to ensure that total codon frequencies always meet the minimum "
             "codon threshold. \"both\" is needed as an option in addition to \"remaining\" so "
             "dynamic codon filtering by `--exclude-amino-acid-count/fraction` operates on genes "
             "that passed the first length filter.")
    groupG.add_argument(
        '--query-min-analyzed-codons', type=int, default=100,
        help="Only allow CUB to calculated for a query if has at least this number of synonymous "
             "codons that will be analyzed. For reference-dependent CUB metrics, analyzed codons "
             "are those with reference compositions.")

    groupH = parser.add_argument_group(
        'FILTER REFERENCE',
        "Confidence in the reference codon composition can be increased by setting minimum "
        "frequency requirements for the set of reference genes or codons for any individual amino "
        "acid to be retained.")
    groupH.add_argument(
        '--reference-exclude-amino-acid-count', type=int, default=5,
        help="Exclude codons for amino acids with fewer than this many codons in the set of "
             "reference genes.")
    groupH.add_argument(
        '--reference-min-codons', type=int, default=100,
        help="Only allow CUB to be calculated for a genome if the set of reference genes contains "
             "at least this many codons. This filter applies after excluding codons for individual "
             "amino acids using `--reference-exclude-amino-acid-count`.")

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
