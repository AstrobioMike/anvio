#!/usr/bin/env python
# -*- coding: utf-8

"""
Copyright (C) 2014, PaPi Authors

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

Please read the COPYING file.
"""

import os
import sys

import PaPi.db as db
import PaPi.genes as genes
import PaPi.utils as utils
import PaPi.dictio as dictio
import PaPi.terminal as terminal
import PaPi.annotation as annotation 
import PaPi.filesnpaths as filesnpaths
from PaPi.profiler import __version__

run = terminal.Run()
progress = terminal.Progress()


def generate_gexf_network_file(units, samples_dict, output_file, sample_mapping_dict = None,
                               unit_mapping_dict = None, project = None, sample_size=8, unit_size=2,
                               skip_sample_labels = False, skip_unit_labels = False):
    output = open(output_file, 'w')

    samples = sorted(samples_dict.keys())
    sample_mapping_categories = sorted([k for k in sample_mapping_dict.keys() if k != 'colors']) if sample_mapping_dict else None
    unit_mapping_categories = sorted([k for k in unit_mapping_dict.keys() if k not in ['colors', 'labels']]) if unit_mapping_dict else None
    
    output.write('''<?xml version="1.0" encoding="UTF-8"?>\n''')
    output.write('''<gexf xmlns:viz="http:///www.gexf.net/1.1draft/viz" xmlns="http://www.gexf.net/1.2draft" version="1.2">\n''')
    output.write('''<meta lastmodifieddate="2010-01-01+23:42">\n''')
    output.write('''    <creator>Oligotyping pipeline</creator>\n''')
    if project:
        output.write('''    <creator>Network description for %s</creator>\n''' % (project))
    output.write('''</meta>\n''')
    output.write('''<graph type="static" defaultedgetype="undirected">\n\n''')

    if sample_mapping_dict:
        output.write('''<attributes class="node" type="static">\n''')
        for i in range(0, len(sample_mapping_categories)):
            category = sample_mapping_categories[i]
            output.write('''    <attribute id="%d" title="%s" type="string" />\n''' % (i, category))
        output.write('''</attributes>\n\n''')

    # FIXME: IDK what the hell is this one about:
    if unit_mapping_dict:
        output.write('''<attributes class="edge">\n''')
        for i in range(0, len(unit_mapping_categories)):
            category = unit_mapping_categories[i]
            output.write('''    <attribute id="%d" title="%s" type="string" />\n''' % (i, category))
        output.write('''</attributes>\n\n''')

    output.write('''<nodes>\n''')
    for sample in samples:
        if skip_sample_labels:
            output.write('''    <node id="%s">\n''' % (sample))
        else:
            output.write('''    <node id="%s" label="%s">\n''' % (sample, sample))
        output.write('''        <viz:size value="%d"/>\n''' % sample_size)
        if sample_mapping_dict and sample_mapping_dict.has_key('colors'):
            output.write('''        <viz:color r="%d" g="%d" b="%d" a="1"/>\n''' %\
                                             HTMLColorToRGB(sample_mapping_dict['colors'][sample], scaled = False))

        if sample_mapping_categories:
            output.write('''        <attvalues>\n''')
            for i in range(0, len(sample_mapping_categories)):
                category = sample_mapping_categories[i]
                output.write('''            <attvalue id="%d" value="%s"/>\n''' % (i, sample_mapping_dict[category][sample]))
            output.write('''        </attvalues>\n''')

        output.write('''    </node>\n''')

    for unit in units:
        if skip_unit_labels:
            output.write('''    <node id="%s">\n''' % (unit))
        else:
            if unit_mapping_dict and unit_mapping_dict.has_key('labels'):
                output.write('''    <node id="%s" label="%s">\n''' % (unit, unit_mapping_dict['labels'][unit]))
            else:
                output.write('''    <node id="%s">\n''' % (unit))
        output.write('''        <viz:size value="%d" />\n''' % unit_size)

        if unit_mapping_categories:
            output.write('''        <attvalues>\n''')
            for i in range(0, len(unit_mapping_categories)):
                category = unit_mapping_categories[i]
                output.write('''            <attvalue id="%d" value="%s"/>\n''' % (i, unit_mapping_dict[category][unit]))
            output.write('''        </attvalues>\n''')

        output.write('''    </node>\n''')

    output.write('''</nodes>\n''')
    
    edge_id = 0
    output.write('''<edges>\n''')
    for sample in samples:
        for i in range(0, len(units)):
            unit = units[i]
            if samples_dict[sample][unit] > 0.0:
                if unit_mapping_dict:
                    output.write('''    <edge id="%d" source="%s" target="%s" weight="%f">\n''' % (edge_id, unit, sample, samples_dict[sample][unit]))
                    output.write('''        <attvalues>\n''')
                    for i in range(0, len(unit_mapping_categories)):
                        category = unit_mapping_categories[i]
                        output.write('''            <attvalue id="%d" value="%s"/>\n''' % (i, unit_mapping_dict[category][unit]))
                    output.write('''        </attvalues>\n''')
                    output.write('''    </edge>\n''')
                else:
                    output.write('''    <edge id="%d" source="%s" target="%s" weight="%f" />\n''' % (edge_id, unit, sample, samples_dict[sample][unit]))


                edge_id += 1
    output.write('''</edges>\n''')
    output.write('''</graph>\n''')
    output.write('''</gexf>\n''')
    
    output.close()


class NetworkDescriptonSamples:
    def __init__(self):
        self.runinfo_path = None
        self.annotation_db_path = None
        self.use_named_functions_only = False
        self.runinfo = None
        self.functions = {}
        self.P = lambda x: os.path.join(os.path.dirname(self.runinfo_path), x)


    def init(self):
        filesnpaths.is_file_exists(self.runinfo_path)
        filesnpaths.is_file_exists(self.annotation_db_path)

        self.runinfo = dictio.read_serialized_object(self.runinfo_path)
        self.profile_db_path = self.P(self.runinfo['profile_db'])
        self.profile_db = db.DB(self.profile_db_path, __version__)

        self.annotation_db = db.DB(self.annotation_db_path, annotation.__version__)

        table_names = self.profile_db.get_table_names()

        if not int(self.profile_db.get_meta_value('merged')):
            raise utils.ConfigError, "The profile database describes a single run. Current implementation of this\
                                      program restricts its use to merged runs. Sorry :/"

        if 'genes' not in table_names:
            raise utils.ConfigError, "There is no 'genes' table in the profile database. Probably you did not\
                                      profile these samples with the presence of an annotation database.\
                                      If that is not the case maybe you should get in touch with the developers :/"

        self.genes_dict = self.profile_db.get_table_as_dict('genes')
        self.samples = sorted(list(set([r['sample_id'] for r in self.genes_dict.values()])))
        self.genes = sorted(list(set([r['prot'] for r in self.genes_dict.values()])))

        # read functions.
        self.annotation_table = self.annotation_db.get_table_as_dict('annotation')
        for gene in self.annotation_table:
            if self.annotation_table[gene]['function']:
                self.functions[gene] = self.annotation_table[gene]['function']


        # make sure every gene self.functions has representation in genes_dict:
        for gene in self.functions:
            if not gene in self.genes:
                raise utils.ConfigError, "Annotation database and the genes table in the profile database disagrees.\
                                          Are you sure you are using the right annotation database?" 

        self.samples_dict = self.get_samples_dict(self.samples, self.genes_dict)
        run.info('init', 'Genes database initialized for %d genes in %d samples.' % (len(self.genes), len(self.samples)))


    def generate_genes_network(self):
        network_desc_output_path = self.P('SAMPLE-GENE-NETWORK.gexf')
        progress.new('Processing')
        progress.update('Generating the network description')
        network_desc = generate_gexf_network_file(self.genes,
                                                  self.samples_dict,
                                                  network_desc_output_path)
        progress.end()
        run.info('network with genes', network_desc_output_path)


    def generate_functions_network(self):
        functions = []
        samples_functions_dict = {}
        for sample in self.samples_dict:
            samples_functions_dict[sample] = {}
            for gene in self.samples_dict[sample]:
                if gene in self.functions:
                    function = self.functions[gene]
                    functions.append(function)
                    if function in samples_functions_dict[sample]:
                        samples_functions_dict[sample][function] += self.samples_dict[sample][gene]
                    else:
                        samples_functions_dict[sample][function] = self.samples_dict[sample][gene]

        network_desc_output_path = self.P('SAMPLE-FUNCTION-NETWORK.gexf')
        progress.new('Processing')
        progress.update('Generating sample-function network description')
        network_desc = generate_gexf_network_file(functions,
                                                  samples_functions_dict,
                                                  network_desc_output_path)
        progress.end()
        run.info('network with functions', network_desc_output_path)



    def get_samples_dict(self, samples, table, unit = 'prot'):
        samples_dict = {}
        for sample in samples:
            samples_dict[sample] = {}
        for v in table.values():
            samples_dict[v['sample_id']][v[unit]] = v['mean_coverage']
        return samples_dict


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Generate a network description file')
    parser.add_argument('runinfo', metavar = 'RUNINFO',
                        help = 'PaPi RUNINFO file')
    parser.add_argument('annotation_db', metavar = 'ANNOTATION',
                        help = 'Annotation database that has been used for the run described in RUNINFO file')

    args = parser.parse_args()

    try:
        network = NetworkDescriptonSamples()
        network.runinfo_path = args.runinfo
        network.annotation_db_path = args.annotation_db
        network.init()
        network.generate_genes_network()
        network.generate_functions_network()
    except utils.ConfigError, e:
        print e
        sys.exit(-1)
    except filesnpaths.FilesNPathsError, e:
        print e
        sys.exit(-2)
