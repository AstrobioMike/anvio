# -*- coding: utf-8

import argparse
import os
import pandas as pd

import anvio
import anvio.utils as u
import anvio.workflows as w

from anvio.errors import ConfigError
from anvio.workflows.ribo_phylo import RibosomalPhylogeneticsWorkflow

__author__ = "Matthew S. Schechter"
__copyright__ = "Copyright 2017, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Matthew S. Schechter"
__email__ = "mschechter@uchicago.edu"


# slave_mode = False if 'workflows/ribo_phylo' in workflow.included[0] else True

# if not slave_mode:
#     # it is important that this comes before the include statement since
#     # M is defined here and will also be used in the contigs workflow
#     M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
#     M.init()
#     dirs_dict = M.dirs_dict
#     # in order to generate the contigs databases we include the snakefile
#     # for the generation of contigs databases
#     include: w.get_workflow_snake_file_path('metagenomics')

M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
M.init()

dirs_dict = M.dirs_dict

# NOTE: user should run workflow until the rule get_gap_count_distribution. This can be done by running the command:
# $ anvi-run-workflow -w ribo_phylo -c config.json -A --until cat_misc_data_to_one_file
# This will allow the user to explore the gap distribution of the SCG MSA and decide an appropriate threshold. Currently,
# the threshold is fixed at 1.5*IQR. After the user has decided on a threshold they can add it to the config file

report: "report/workflow.rst"

rule ribo_phylo_workflow_target_rule:
    input: M.target_files

rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins:
    """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(M.contig_dir, "{sample_name}-contigs.db")
    output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fasta")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
	shell: "anvi-get-sequences-for-hmm-hits -c {input} \
                                       {params.hmm_source} \
                                       --get-aa-sequences \
                                       --gene-name {wildcards.ribosomal_protein_name} \
                                       -o {output} 2> {log}"


rule anvi_estimate_scg_taxonomy_for_ribosomal_proteins:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(M.contig_dir, "{sample_name}-contigs.db")
    output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
    params:
        metagenome_mode = M.get_rule_param('anvi_estimate_scg_taxonomy_for_ribosomal_proteins', '--metagenome-mode')
    threads: M.T('anvi_estimate_scg_taxonomy_for_ribosomal_proteins')
	shell:
		"anvi-estimate-scg-taxonomy -c {input} \
                                 	{params.metagenome_mode} \
                                 	--scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
                                 	-o {output} 2> {log}"


rule filter_for_scg_sequences_and_metadata:
    """Remove sequences that do not have SCG taxonomy"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "filter_for_scg_sequences_and_metadata_{sample_name}_{ribosomal_protein_name}.log")
    input:
        SCG_taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv"),
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fasta")
    output:
        fasta_filtered = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fasta"),
        misc_data = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_misc_data.tsv"),
        gene_callers_ids = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids.tsv")

    threads: M.T('filter_for_scg_sequences_and_metadata')
    script:
        "scripts/filter_for_scg_sequences_and_metadata.py"

rule anvi_get_sequences_for_gene_calls:
    """Get nucleotide sequences for gene calls

        Here we start the mapping section of the workflow by getting the nucleotide fastas
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_gene_calls_{sample_name}_{ribosomal_protein_name}.log")
    input:
        contigsDBs = os.path.join(M.contig_dir, "{sample_name}-contigs.db"),
        gene_callers_ids = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids.tsv")
    output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fna")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    shell:
        """
        anvi-get-sequences-for-gene-calls -c {input.contigsDBs} \
                                    --gene-caller-ids {input.gene_callers_ids} \
                                    -o {output} 2> {log}
        """


rule rename_gene_calls:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "rename_gene_calls_{sample_name}_{ribosomal_protein_name}.log")
    input:
        fna = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fna"),
        report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt")
    output:
        fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_renamed.fna")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script:
        "scripts/rename_fasta_headers.py"

rule cat_SCG_NT_to_one_fasta:
    """DOC string
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_SCG_NT_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{sample_names}", "{sample_names}_{ribosomal_protein_names}_renamed.fna"), sample_names = M.external_genome_name_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all.fna")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output}"


rule cluster_90_mmseqs:
    """Remove redundant ribosomal sequences with mmseqs"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cluster_90_mmseqs_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all.fna")
    output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
    params:
        output_prefix = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR"),
        mmseqs_tmp = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_tmp"),
        min_seq_id = M.get_param_value_from_config(['remove_redundant_sequences_mmseqs', '--min-seq-id'])
    threads: M.T('remove_redundant_sequences_mmseqs')
    shell:
        "mmseqs easy-cluster {input} \
                             {params.output_prefix} \
                             {params.mmseqs_tmp} \
                             --min-seq-id {params.min_seq_id} >> {log} 2>&1"

rule cat_ribo_proteins_to_one_fasta:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_names}", "{sample_names}_{ribosomal_protein_names}.fasta"), sample_names = M.external_genome_name_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta"),
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output}"

rule get_filtered_gene_callers_ids_for_mapping:
    """
    Retrieve the gene-callers-ids from the representative sequences for anvi_get_sequences_for_gene_calls
    to extract the sequences with 150 nt leeway upstream and downstream
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        reps = os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta"),
        report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}","{ribosomal_protein_name}_reformat_report_all.txt")
    output:
         report_file_filtered = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_reformat_report_msa2.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script:
        "scripts/get_gene_caller_ids_for_mapping.py"

rule anvi_get_gene_caller_ids_for_reps:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_gene_calls_reps_{sample_name}_{ribosomal_protein_name}.log")
    input:
        gene_callers_ids = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids.tsv"),
        reformat_file_filtered = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_reformat_report_msa2.txt")
    output:
        gene_callers_ids_reps = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids_reps.tsv"),
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script:
        "scripts/filter_gene_caller_ids_for_repts.py"


rule anvi_get_sequences_for_gene_calls_reps_with_leeway:
    """
    Here we will extract the representative nt sequences for mapping BUT with flanking sequences
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_gene_calls_reps_{sample_name}_{ribosomal_protein_name}.log")
    input:
        contigsDBs = os.path.join(M.contig_dir, "{sample_name}-contigs.db"),
        gene_callers_ids = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids_reps.tsv")
    output:
        fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reps_leeway.fna"),
        external_gene_calls = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls.tsv")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    shell:
        """
        anvi-get-sequences-for-gene-calls -c {input.contigsDBs} \
                                    --gene-caller-ids {input.gene_callers_ids} \
                                    --flank-length 150 \
                                    --external-gene-calls {output.external_gene_calls} \
                                    -o {output.fasta} 2> {log}
        """


rule rename_gene_calls_reps:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "rename_gene_calls_{sample_name}_{ribosomal_protein_name}.log")
    input:
        fna = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reps_leeway.fna"),
        report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt"),
        external_gene_calls = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls.tsv")
    output:
        fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reps_leeway_renamed.fna"),
        external_gene_calls = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls_renamed.tsv")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script:
        "scripts/rename_fasta_headers_nt.py"

rule cat_SCG_NT_to_one_fasta_reps:
    """DOC string
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_SCG_NT_to_one_fasta_reps_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{sample_names}", "{sample_names}_{ribosomal_protein_names}_reps_leeway_renamed.fna"), sample_names = M.external_genome_name_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_leeway.fna")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output}"


# rule add_header_SCG_NT_external_gene_calls:
#     """
#     Need to add a head to the {ribosomal_protein_name}_all_leeway_external_gene_calls.tsv
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
#     output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_leeway_external_gene_calls.tsv")
#     threads: M.T('cat_misc_data_to_one_file')
#     shell:
#         """
#         echo -e "header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n$(grep -v "header" {input})" > {output}
#         """

rule cat_SCG_NT_external_gene_calls:
    """
    FIXME: double check again that the leeway sequences are the correct orientation etc
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_SCG_NT_to_one_fasta_reps_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{sample_names}", "{sample_names}_{ribosomal_protein_names}_external_gene_calls_renamed.tsv"), sample_names = M.external_genome_name_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_leeway_external_gene_calls.tsv")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat <({input}) >> {output}"

rule anvi_reformat_fasta_SCG_NT:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_reps_leeway.fna")
    output:
        fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_reps_leeway_renamed.fna"),
        report_file = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_reps_leeway_renamed_reformat_report_all.txt")
    params:
        prefix = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--prefix"),
        keep_ids = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--keep-ids"),
        exclude_ids = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--exclude-ids"),
        simplify_names = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--simplify-names")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              {params.simplify_names} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

rule anvi_reformat_fasta_ribosomal_protein_file:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta")
    output:
        fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_renamed.fasta"),
        report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt")
    params:
        prefix = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--prefix"),
        keep_ids = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--keep-ids"),
        exclude_ids = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--exclude-ids"),
        simplify_names = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--simplify-names")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              {params.simplify_names} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"


rule cat_misc_data_to_one_file:
    """
    Cat all sequence misc data from separate samples in one tsv.

    FIXME: The header is removed when concatenating all the files together. THis
    is done because otherwise the headers will be printed multiple times throughout
    the file. To avoid this I remove the header line before concatentating. In the
    next rule I add the header back to the top of the line... THis is not elegant and
    sucks.
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_misc_data.tsv"), sample_name = M.external_genome_name_list, ribosomal_protein_name = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        "cat {input} >> {output}"

rule add_header_to_misc_file:
    """
    Adding header to misc data file.

    See rule cat_misc_data_to_one_file for why this sucks

    FIXME: replace with sed when running on linux

    # grep -v "header" {input} | sed -i '1s|^|header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n|' > {output}

    FIXME: the tmp misc_data files before *_all_misc_data_final.tsv could be removed from the final output
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        """
        echo -e "header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n$(grep -v "header" {input})" > {output}
        """

rule join_renamed_fasta_with_misc_data:
    """Add simplified fasta headers to the misc data file"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "join_renamed_fasta_with_misc_data_{ribosomal_protein_name}.log")
    input:
        misc_data_all = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
        reformat_report_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt")
    output: misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
    threads: M.T('join_renamed_fasta_with_misc_data')
    script:
        "scripts/join_renamed_fasta_with_misc_data.py"


rule remove_redundant_sequences_mmseqs:
    """Remove redundant ribosomal sequences with mmseqs"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_redundant_sequences_mmseqs_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_renamed.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
    params:
        output_prefix = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_mmseqs_NR"),
        mmseqs_tmp = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_tmp"),
        min_seq_id = M.get_param_value_from_config(['remove_redundant_sequences_mmseqs', '--min-seq-id'])
    threads: M.T('remove_redundant_sequences_mmseqs')
    shell:
        "mmseqs easy-cluster {input} \
                             {params.output_prefix} \
                             {params.mmseqs_tmp} \
                             --min-seq-id {params.min_seq_id} >> {log} 2>&1"

# Initial alignment, trim, and removal of sequences with 50% gaps or more
rule align_muscle:
    """Initial alignment with muscle"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_{ribosomal_protein_name}.log")
	input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
	output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
	threads: M.T('align_muscle')
	shell:
		"muscle -in {input} \
				-out {output} 2> {log}"


# FIXME: odseq in R will only accept a MSA object from the package MSA
# The MSA package does have muscle as an option for the alignment 
# algorithm to use but this would mean a massive MSA calculation in R
# NOT in the mood to figure our the ramifications of this at the moment
# but I have a feeling that this will really slow down the workflow.
# Now that I have the --gappyout parameter in trimal, I should be 
# doing a smarter job at trimming and subsequently removing sequences that 
# have a high percentage of gaps. 
# rule remove_outlier_seqs_odseq:
#     """Removing sequences that have > 50% gaps"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_odseq.fasta")
#     threads: M.T('remove_gaps')
#     script:
#         "scripts/odseq_remove_outliers.R --msa {input} --output"

rule trim_alignment:
    """trim alignment


    FIXME: rant on ordering of trimming and sequence removal steps, need to think about this deeper, not conclusive:

    I think that trimming twice may not be optimal. Here is my logic:
    Trimal is all about removing MSA positions (columns) that contain a threshold proportion of gaps
    i.e. trimming "horizontally". Positions with a lot of gaps are removed because they are
    phylogenetically uninformative. If we trimm before removing all sequences we might be
    making sequences seem more aligned because we have just removed gaps.

    I think trimming should be the very last step in the MSA curation.
    for example:
    (1) cluster at 100%
    (2) calculate MSA
    (3) remove sequences based on gap distribution (anvi-script-reformat-fasta)
    (4) remove positions with a lot of gaps (trimal)

    Another thing to consider is calculating a tree based on representative sequences from a
    clustered dataset. I already need to do this when I pick representative for the mapping
    steps. Why not just use that set to calculate the tree? Also, the over MSA might be
    higher quality because there is less noise with similar sequences.
    for example:
    (1) cluster at 90%
    (2) calculate MSA
    (3) remove sequences with a lot of gaps (anvi-script-reformat-fasta)
    (4) remove positions with a lot of gaps (trimal)
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
    params:
        gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
        gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
        additional_params = M.get_param_value_from_config(['trim_alignment', 'additional_params'])
    shell:
        'trimal -in {input} \
                -out {output} \
                {params.gappyout} \
                {params.additional_params} 2> {log}'

rule remove_sequences_with_X_percent_gaps:
    """Removing sequences that have > 50% gaps"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
    params:
        seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_01"),
        max_percentage_gaps=M.get_param_value_from_config(['remove_sequences_with_X_percent_gaps', '--max-percentage-gaps'])
    threads: M.T('remove_gaps')
	shell:
		"anvi-script-reformat-fasta {input} \
									-o {output} \
									--max-percentage-gaps {params.max_percentage_gaps} \
									--export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# Remove sequences that have an outlier set of gaps in a sequences
# - this step further refines the MSA by removing more sequences that have too many gaps.
# to make this smarter, we will rely on the standard outlier threshold of 1.5*IQR and remove any
# sequences with more gaps than that. To accomplish this the following steps will be taken:
# * Get the distribution of gaps counts per sequences
# * calculate the outlier threshold 1.5*IQR
# * remove sequences greater than that threshold

rule get_gap_count_distribution:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gap_count_distribution_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
    output: seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02.tsv")
    params: tmp_asdf=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02_tmp"),
            seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02")
    threads: M.T('get_gap_count_distribution')
    shell:
        "anvi-script-reformat-fasta {input} \
                                    -o {params.tmp_asdf} \
                                    --export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

rule filter_out_outlier_sequences:
    """Filter out sequences with more gaps than the 1.5*IQR of the gap distribution across all sequences"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "filter_out_outlier_sequences_{ribosomal_protein_name}.log")
    input:
        tsv = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02.tsv"),
        fasta = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
    params:
        gap_threshold = M.get_param_value_from_config(['MSA_gap_threshold'])
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
    threads: M.T('filter_out_outlier_sequences')
    script:
        "scripts/filter_gap_count_outlier_sequence.py"

rule align_muscle_2:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_2_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
    output: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
    threads: M.T('align_muscle_2')
    shell:
        "muscle -in {input} \
                -out {output} 2> {log}"

rule trim_alignment_2:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_2_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
    output: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
    params:
        gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
        gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
        additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
    shell:
        'trimal -in {input} \
                -out {output} \
                {params.gappyout} \
                {params.additional_params} 2> {log}'


rule count_num_sequences_filtered:
    """This rule will count the number of Ribosomal sequences filtered at each step of the workflow"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "count_num_sequences_filtered_{ribosomal_protein_name}.log")
    input:
        step1 = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_renamed.fasta"),
        step2 = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta"),
        step3 = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta"),
        step4 = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta"),
        step5 = os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_STATS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_stats.tsv")
    threads: M.T('trim_alignment_2')
    shell:
        """
        # Headers
        echo -e "Description\tRule_name\tNum_sequences\n > {output}"

        # Rule: anvi_reformat_fasta_ribosomal_protein_file
        step1=$(grep -c '>' {input.step1})
        echo -e "Input_numseq_from_all_MG\tanvi_reformat_fasta_ribosomal_protein_file\t$step1\n" > {output}

        # Rule: remove_redundant_sequences_mmseqs
        step2=$(grep -c '>' {input.step2})
        echo -e "NR_sumseq\tremove_redundant_sequences_mmseqs\t$step2\n" >> {output}

        # Rule: remove_gaps
        step3=$(grep -c '>' {input.step3})
        echo -e "seq_X_gaps_removed\tremove_sequences_with_X_percent_gaps\t$step3\n" >> {output}

        # Rule: filter_out_outlier_sequences
        step4=$(grep -c '>' {input.step4})
        echo -e "remove_outliers\tfilter_out_outlier_sequences\t$step4\n" >> {output}

        # Rule: trim_alignment_2
        step5=$(grep -c '>' {input.step4})
        echo -e "num_seq_for_tree\ttrim_alignment_2\t$step5\n" >> {output}
        """

# 4. Calculate the tree, FINALLY

rule calculate_tree:
    """Calculate a phylogenetic tree using iqtree"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "calculate_tree_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
    output: report(os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}.iqtree"), category="report/iqtree_{ribosomal_protein_name}.rst")
    params:
        outfile=os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}"),
        model = M.get_param_value_from_config(['calculate_tree', '-m']),
        additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
    threads: M.T('calculate_tree')
    shell:
        "iqtree -s {input} \
                -nt AUTO \
                -m {params.model} \
                -pre {params.outfile} \
                {params.additional_params} >> {log} 2>&1"