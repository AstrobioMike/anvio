# -*- coding: utf-8

import argparse
import os
import pandas as pd

import anvio
import anvio.utils as u
import anvio.workflows as w

from anvio.errors import ConfigError
from anvio.workflows.ribo_phylo import RibosomalPhylogeneticsWorkflow

__author__ = "Matthew S. Schechter"
__copyright__ = "Copyright 2017, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Matthew S. Schechter"
__email__ = "mschechter@uchicago.edu"


M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
M.init()

dirs_dict = M.dirs_dict

# NOTE: user should run workflow until the rule get_gap_count_distribution. This can be done by running the command:
# $ anvi-run-workflow -w ribo_phylo -c config.json -A --until cat_misc_data_to_one_file
# This will allow the user to explore the gap distribution of the SCG MSA and decide an appropriate threshold. Currently,
# the threshold is fixed at 1.5*IQR. After the user has decided on a threshold they can add it to the config file

print("the gap threshold is: " + M.MSA_gap_threshold)

rule ribo_phylo_workflow_target_rule:
    input: M.target_files

rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins:
    """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(M.contig_dir, "{sample_name}-contigs.db")
    output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_all.fasta")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
	shell: "anvi-get-sequences-for-hmm-hits -c {input} \
                                       {params.hmm_source} \
                                       --get-aa-sequences \
                                       --gene-name {wildcards.ribosomal_protein_name} \
                                       -o {output} 2> {log}"


rule anvi_estimate_scg_taxonomy_for_ribosomal_proteins:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(M.contig_dir, "{sample_name}-contigs.db")
    output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
    threads: M.T('anvi_estimate_scg_taxonomy_for_ribosomal_proteins')
	shell:
		"anvi-estimate-scg-taxonomy -c {input} \
                                 	--metagenome-mode \
                                 	--scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
                                 	-o {output} 2> {log}"


rule filter_for_scg_sequences_and_metadata:
    """Remove sequences that do not have SCG taxonomy"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "filter_for_scg_sequences_and_metadata_{sample_name}_{ribosomal_protein_name}.log")
    input:
        SCG_taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv"),
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_all.fasta")
    output:
        fasta_filtered = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fasta"),
        misc_data = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_misc_data.tsv")
    threads: M.T('filter_for_scg_sequences_and_metadata')
    script:
        "scripts/filter_for_scg_sequences_and_metadata.py"


rule cat_ribo_proteins_to_one_fasta:
    """Cat all ribosomal sequences from seperate metagenomes into one fasta"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_names}", "{sample_names}_{ribosomal_protein_names}.fasta"), sample_names = M.sample_name_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_all.fasta"),
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output}"


rule anvi_reformat_fasta_ribosomal_protein_file:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_all.fasta")
    output:
        fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_all_renamed.fasta"),
        report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_reformat_report_all.txt")
    params:
        prefix = M.get_rule_param("anvi_script_reformat_fasta", "--prefix"),
        keep_ids = M.get_rule_param("anvi_script_reformat_fasta", "--keep-ids"),
        exclude_ids = M.get_rule_param("anvi_script_reformat_fasta", "--exclude-ids"),
        simplify_names = M.get_rule_param("anvi_script_reformat_fasta", "--simplify-names")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

rule cat_misc_data_to_one_file:
    """Cat all sequence misc data from separate samples in one tsv"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_misc_data.tsv"), sample_name = M.sample_name_list, ribosomal_protein_name = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_TREES'], "{ribosomal_protein_name}_all_misc_data.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        "cat {input} >> {output}"


rule join_renamed_fasta_with_misc_data:
    """Add simplified fasta headers to the misc data file"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "join_renamed_fasta_with_misc_data_{ribosomal_protein_name}.log")
    input:
        misc_data_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_all_misc_data.tsv"),
        reformat_report_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_reformat_report_all.txt")
    output: misc_data_final = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_misc_data_final.tsv")
    threads: M.T('join_renamed_fasta_with_misc_data')
    script:
        "scripts/join_renamed_fasta_with_misc_data.py"


rule remove_redundant_sequences_mmseqs:
    """Remove redundant ribosomal sequences with mmseqs"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_redundant_sequences_mmseqs_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_all_renamed.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_NR_rep_seq.fasta")
    params:
        output_prefix = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_NR"),
        mmseqs_tmp = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_tmp")
    threads: M.T('remove_redundant_sequences_mmseqs')
    shell:
        "mmseqs easy-cluster {input} \
                             {params.output_prefix} \
                             {params.mmseqs_tmp} \
                             --min-seq-id 1 >> {log} 2>&1"

# Initial alignment, trim, and removal of sequences with 50% gaps or more
rule align_muscle:
    """Initial alignment with muscle"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_{ribosomal_protein_name}.log")
	input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_NR_rep_seq.fasta")
	output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_aligned.fasta")
	threads: M.T('align_muscle')
	shell:
		"muscle -in {input} \
				-out {output} 2> {log}"

rule trim_alignment:
    """trim alignment"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_{ribosomal_protein_name}.log")
	input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_aligned.fasta")
	output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed.fasta")
    # threads: M.T('trim_alignment')
	shell:
		"trimal -in {input} \
				-out {output} \
				-gt 0.50 2> {log}"

rule remove_gaps:
    """Removing sequences that have > 50% gaps"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed_gaps_removed.fasta")
    params: seq_counts_tsv=os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_gaps_counts_01")
    threads: M.T('remove_gaps')
	shell:
		"anvi-script-reformat-fasta {input} \
									-o {output} \
									--max-percentage-gaps 50 \
									--export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# Remove sequences that have an outlier set of gaps in a sequences
# - this step further refines the MSA by removing more sequences that have too many gaps.
# to make this smarter, we will rely on the standard outlier threshold of 1.5*IQR and remove any
# sequences with more gaps than that. To accomplish this the following steps will be taken:
# * Get the distribution of gaps counts per sequences
# * calculate the outlier threshold 1.5*IQR
# * remove sequences greater than that threshold

rule get_gap_count_distribution:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gap_count_distribution_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed_gaps_removed.fasta")
    output: seq_counts_tsv=os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_gaps_counts_02.tsv")
    params: tmp_asdf=os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_gaps_counts_02_tmp"),
            seq_counts_tsv=os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_gaps_counts_02")
    threads: M.T('get_gap_count_distribution')
    shell:
        "anvi-script-reformat-fasta {input} \
                                    -o {params.tmp_asdf} \
                                    --export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

rule filter_out_outlier_sequences:
    """Filter out sequences with more gaps than the 1.5*IQR of the gap distribution across all sequences"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "filter_out_outlier_sequences_{ribosomal_protein_name}.log")
    input:
        tsv = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_gaps_counts_02.tsv"),
        fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed_gaps_removed.fasta")
    params:
        gap_threshold = M.MSA_gap_threshold
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed_gaps_removed_final.fasta")
    threads: M.T('filter_out_outlier_sequences')
    script:
        "scripts/filter_gap_count_outlier_sequence.py"


# 3. Re-prepare MSA for tree calculation
# Repeat step 1. now that we have the final set of sequences that don't have too many gaps

rule align_muscle_2:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_2_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_1'], "{ribosomal_protein_name}_trimmed_gaps_removed_final.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_2'], "{ribosomal_protein_name}_aligned.fasta")
    threads: M.T('align_muscle_2')
    shell:
        "muscle -in {input} \
                -out {output} 2> {log}"

rule trim_alignment_2:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_2_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_2'], "{ribosomal_protein_name}_aligned.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_2'], "{ribosomal_protein_name}_trimmed.fasta")
    threads: M.T('trim_alignment_2')
    shell:
        "trimal -in {input} \
                -out {output} \
                -gt 0.50 2> {log}"


rule count_num_sequences_filtered:
    """This rule will count the number of Ribosomal sequences filtered at each step of the workflow"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "count_num_sequences_filtered_{ribosomal_protein_name}.log")
    input:
        step1 = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_all_renamed.fasta"),
        step2 = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}_NR_rep_seq.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_STATS'], "{ribosomal_protein_name}_stats.tsv")
    threads: M.T('trim_alignment_2')
    shell:
        """
        echo -n "Rule\tNum_sequences\n"
        step1=$(grep -c '>' {input.step1})
        echo -n "step1\t$step1\n" > {output}

        step2=$(grep -c '>' {input.step2})
        echo -n "step2\t$step2\n" >> {output}
        """
# 4. Calculate the tree, FINALLY

rule calculate_tree:
    """This rule will..."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "calculate_tree_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_2'], "{ribosomal_protein_name}_trimmed.fasta")
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_TREES'], "{ribosomal_protein_name}.contree")
    params:
        outfile=os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_TREES'], "{ribosomal_protein_name}")
    threads: M.T('calculate_tree')
    shell:
        "iqtree -s {input} \
                -nt {threads} \
                -m MFP \
                -bb 1000 \
                -pre {params.outfile} 2> {log}"