# -*- coding: utf-8
import os
import glob
import os.path
import argparse

import pandas as pd

import anvio
import anvio.utils as u
import anvio.workflows as w

from Bio import SeqIO
from anvio.errors import ConfigError
from anvio.workflows.ribo_phylo import RibosomalPhylogeneticsWorkflow

__author__ = "Matthew S. Schechter"
__copyright__ = "Copyright 2017, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Matthew S. Schechter"
__email__ = "mschechter@uchicago.edu"

slave_mode = False if 'workflows/ribo_phylo' in workflow.included[0] else True

# if not slave_mode:
#     # it is important that this comes before the include statement since
#     # M is defined here and will also be used in the contigs workflow
#     M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
#     M.init()
#     dirs_dict = M.dirs_dict
#     # in order to generate the contigs databases we include the snakefile
#     # for the generation of contigs databases
#     include: w.get_workflow_snake_file_path('metagenomics')

M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
M.init()

dirs_dict = M.dirs_dict

rule ribo_phylo_workflow_target_rule:
    input: M.target_files

rule anvi_run_hmms_hmmsearch:
    """run hmmsearch to get domtblout so that I can filter out hits with low query coverage"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_run_hmms_hmmsearch_{sample_name}.log")
    input:
        lambda wildcards: os.path.join(M.input_dirs_dict[wildcards.sample_name], "%s-contigs.db" % wildcards.sample_name)
    output:
        os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}_dom_hmmsearch", "hmm.domtable")
    threads: M.T('anvi_get_sequences_for_hmm_hits_SCGs')
    run:
      hmmer_output_dir = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "%s_dom_hmmsearch" % wildcards.sample_name)
      shell("anvi-run-hmms -c {input} \
                         --hmmer-program hmmsearch \
                         --hmmer-output-dir %s \
                         -I Bacteria_71 \
                         --get-domtable-output \
                         --just-do-it \
                         -T {threads} 2> {log}" % hmmer_output_dir)

rule filter_hmm_hits_by_query_coverage:
    """Filter hmm_hits table by query coverage"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_run_hmms_hmmsearch_{sample_name}.log")
    input:
        domtblout = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}_dom_hmmsearch", "hmm.domtable"),
        contigsDB = lambda wildcards: os.path.join(M.input_dirs_dict[wildcards.sample_name], "{sample_name}-contigs.db")
    output:
        touch(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}-contigs-contigsDB_filtered.done"))
    params:
        hmm_source = M.get_rule_param('filter_hmm_hits_by_query_coverage', '--hmm-source'),
        query_coverage = M.get_rule_param('filter_hmm_hits_by_query_coverage', '--query-coverage')
    threads: M.T('anvi_get_sequences_for_hmm_hits_SCGs')
    shell:
          "anvi-script-filter-hmm-hits-table -c {input.contigsDB} \
                                             --domtblout {input.domtblout} \
                                             --hmm-source {params.hmm_source} \
                                             --query-coverage {params.query_coverage}"

rule anvi_get_sequences_for_hmm_hits_SCGs_aa:
    """Extract all SCG AA sequences listed in SCG_protein_list.txt from metagenomes.txt and external_genomes.txt"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_SCGs_{sample_name}_{ribosomal_protein_name}.log")
    input:
        done_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}-contigs-contigsDB_filtered.done"),
        contigsDB = lambda wildcards: os.path.join(M.input_dirs_dict[wildcards.sample_name], "%s-contigs.db" % wildcards.sample_name)
    output:
        os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.faa")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_SCGs', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_SCGs')
  	shell: "anvi-get-sequences-for-hmm-hits -c {input.contigsDB} \
                                              {params.hmm_source} \
                                             --get-aa-sequences \
                                             --gene-name {wildcards.ribosomal_protein_name} \
                                             -o {output} 2> {log}"

rule anvi_get_sequences_for_hmm_hits_SCGs_nt:
    """Extract all SCG NT sequences listed in SCG_protein_list.txt from metagenomes.txt and external_genomes.txt"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_SCGs_{sample_name}_{ribosomal_protein_name}.log")
    input:
        done_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}-contigs-contigsDB_filtered.done"),
        contigsDB = lambda wildcards: os.path.join(M.input_dirs_dict[wildcards.sample_name], "%s-contigs.db" % wildcards.sample_name)
    output:
        fna = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_SCGs', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_SCGs')
    shell: "anvi-get-sequences-for-hmm-hits -c {input.contigsDB} \
                                           {params.hmm_source} \
                                           --gene-name {wildcards.ribosomal_protein_name} \
                                           -o {output} 2> {log}"

rule get_external_gene_calls_file:
    """Extract external_gene_calls table from all samples"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_external_gene_calls_file_{sample_name}_{ribosomal_protein_name}.log")
    input:
        done_file= os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}-contigs-contigsDB_filtered.done"),
        contigsDB = lambda wildcards: os.path.join(M.input_dirs_dict[wildcards.sample_name], "%s-contigs.db" % wildcards.sample_name)
    output:
        external_gene_calls_ed = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls_ed.tsv")
    params:
        fasta = temp(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_orfs.fna")),
        external_gene_calls = temp(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_orfs.fna"))
    threads: M.T('anvi_get_sequences_for_hmm_hits_SCGs')
    shell:
          """
          anvi-get-sequences-for-gene-calls -c {input.contigsDB} \
                                            --external-gene-calls {params.external_gene_calls} \
                                            -o {params.fasta} 2> {log};
          awk -v sample="{wildcards.sample_name}" 'NR==1 {{print}} NR>1 {{$2=sample"_"$2; print}}' {params.external_gene_calls} > {output.external_gene_calls_ed}
          """

rule cat_external_gene_calls_file:
    """Cat all external_gene_calls files from all samples into one file"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input:
        external_gene_calls_renamed = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_external_gene_calls_ed.tsv"), sample_names = M.names_list, ribosomal_protein_names = M.SCG_protein_list),
    output:
        external_gene_calls_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_external_gene_calls_all.tsv"),
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input.external_gene_calls_renamed} >> {output.external_gene_calls_all}"

rule rename_and_filter_external_gene_calls_file_all:
    """"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "rename_and_filter_external_gene_calls_file_all_{ribosomal_protein_name}.log")
    input:
        external_gene_calls_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_external_gene_calls_all.tsv"),
        SCGs_nt = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_scgs_for_mapping.fna"),
        reformat_file_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt"),
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_headers_for_mapping.txt")
    output:
        external_gene_calls_renamed = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_external_gene_calls_all_renamed.tsv")
    threads: 5
    script:
        "scripts/rename_external_gene_calls_file.py"

rule anvi_estimate_scg_taxonomy_for_SCGs:
    """Get SCG taxonomy for SCGs in SCG_protein_list.txt"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_SCGs_{sample_name}_{ribosomal_protein_name}.log")
    input:
        lambda wildcards: os.path.join(M.input_dirs_dict[wildcards.sample_name], "{sample_name}-contigs.db")
    output:
        taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
    params:
    threads: M.T('anvi_estimate_scg_taxonomy_for_SCGs')
    message: ""
    run:
        shell('anvi-estimate-scg-taxonomy -c {input} \
                                          --metagenome-mode \
                                          --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
                                          -T {threads} \
                                          -o {output} 2> {log}')

rule simplify_names_from_scg_hits_nt:
    """Clean up fasta headers for tree calculation"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    output:
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.fna"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_nt.txt")
    threads: M.T('anvi_script_reformat_fasta')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --prefix {wildcards.sample_name} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

rule simplify_names_from_scg_hits_aa:
    """Clean up fasta headers for tree calculation"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", '{sample_name}_{ribosomal_protein_name}_hmm_hits.faa')
    output:
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.faa"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_aa.txt")
    threads: M.T('anvi_script_reformat_fasta')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --prefix {wildcards.sample_name} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

def join_fastas(contig_db_type, input_report_file, input_taxonomy, output, sample_name, ribosomal_protein_name):
  """Function to create SCG taxonomy metadata file with reformated names"""

  # Import fasta header index
  #----------------------------
  reformat_report = pd.read_csv(input_report_file, \
                    sep="\t", \
                    index_col=None, \
                    names=['new_header', 'old_header'])

  taxonomy = pd.read_csv(input_taxonomy, \
                    sep="\t", \
                    index_col=None)

  # Clean
  #------
  taxonomy = taxonomy.rename(columns = {'scg_name': 'sequence_name'})

  reformat_report['gene_callers_id'] = reformat_report['old_header'].str.split("gene_callers_id:|\|start:", expand=True)[1].astype(int)
  reformat_report['sequence_name'] = ribosomal_protein_name + '_' + reformat_report['gene_callers_id'].map(str)
  reformat_report['sample'] = sample_name
  reformat_report['contig_db_type'] = contig_db_type # here is where the contig_db_type categorical variable get's set, not very fancy but it works

  # Join
  #-----
  misc_new_headers_df = reformat_report.merge(taxonomy, on="sequence_name", how="left")[['new_header', 'sample', 'contig_db_type', 't_domain', 't_phylum', 't_class', 't_order', 't_family', 't_genus', 't_species']]

  # Export
  #-------
  misc_new_headers_df.to_csv(output, \
             sep="\t", \
             index=None, \
             na_rep="NA", \
             header=False)


rule join_renamed_fastas_with_taxonomy_data_text:
    """Add simplified fasta headers to the misc data file"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "join_renamed_fasta_with_misc_data_{sample_name}_{ribosomal_protein_name}.log")
    input:
        taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_nt.txt"),
    output:
        misc_data_final = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results_ed.tsv")
    params:
        external_genomes = M.external_genomes
    threads: M.T('join_renamed_fasta_with_misc_data')
    run:
        """Here we determine the origin of each SCG (which kind of contigsDB): metagenome, isolate genome, etc."""
        if M.mode == "both":
            if wildcards.sample_name in M.external_genomes_names_list:
              join_fastas(contig_db_type = 'genome',
                          input_report_file = input.report_file,
                          input_taxonomy = input.taxonomy,
                          output = output.misc_data_final,
                          sample_name = wildcards.sample_name,
                          ribosomal_protein_name = wildcards.ribosomal_protein_name)

            if wildcards.sample_name in M.metagenomes_name_list:
              join_fastas(contig_db_type = 'metagenome',
                          input_report_file = input.report_file,
                          input_taxonomy = input.taxonomy,
                          output = output.misc_data_final,
                          sample_name = wildcards.sample_name,
                          ribosomal_protein_name = wildcards.ribosomal_protein_name)

        if M.mode == "external_genomes":

            if wildcards.sample_name in M.external_genomes_names_list:
              join_fastas(contig_db_type = 'genome',
                          input_report_file = input.report_file,
                          input_taxonomy = input.taxonomy,
                          output = output.misc_data_final,
                          sample_name = wildcards.sample_name,
                          ribosomal_protein_name = wildcards.ribosomal_protein_name)

        if M.mode == "metagenomes":
            if wildcards.sample_name in M.metagenomes_name_list:
              join_fastas(contig_db_type = 'metagenome',
                          input_report_file = input.report_file,
                          input_taxonomy = input.taxonomy,
                          output = output.misc_data_final,
                          sample_name = wildcards.sample_name,
                          ribosomal_protein_name = wildcards.ribosomal_protein_name)


rule cat_scgs_to_one_fasta_nt:
    """
    Cat all SCG sequences from seperate metagenomes into one fasta

    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input:
        fasta = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_hmm_hits_renamed.fna"), sample_names = M.names_list, ribosomal_protein_names = M.SCG_protein_list),
    output:
        fasta_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fna"),
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input.fasta} >> {output.fasta_all}"

rule cat_reformat_files_nt:
    """
    Cat all SCG reformat files from seperate metagenomes into one fasta

    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: 
        reformat_file = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_reformat_report_nt.txt"), sample_names = M.names_list, ribosomal_protein_names = M.SCG_protein_list),
    output: 
        reformat_file_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell: 
        "cat {input.reformat_file} >> {output.reformat_file_all}"

rule cat_scgs_to_one_fasta_aa:
    """
    Cat all SCG AA sequences from seperate metagenomes into one fasta

    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_hmm_hits_renamed.faa"), sample_names = M.names_list, ribosomal_protein_names = M.SCG_protein_list)
    output: fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.faa")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output.fasta}"

rule cluster_X_percent_sim_mmseqs:
    """
    mmseqs: cluster SCG NT sequences to remove redundant SCG sequences and precent non-specific read recruitment
    and read recruitment dilution.  
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cluster_90_mmseqs_{ribosomal_protein_name}.log")
    input: rules.cat_scgs_to_one_fasta_nt.output
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
    params:
        output_prefix = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR"),
        mmseqs_tmp = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_tmp"),
        min_seq_id = M.get_param_value_from_config(['remove_redundant_sequences_mmseqs', '--min-seq-id'])
    threads: M.T('remove_redundant_sequences_mmseqs')
    shell:
        "mmseqs easy-cluster {input} \
                             {params.output_prefix} \
                             {params.mmseqs_tmp} \
                             --threads {threads} \
                             --min-seq-id {params.min_seq_id} >> {log} 2>&1"

rule get_headers:
    """Extract sequence headers"""
    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        reps = rules.cluster_X_percent_sim_mmseqs.output,
    output:
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq_headers.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script: "scripts/get_sequence_headers.py"

rule filter_for_aa_seqs:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
    input:
        faa = rules.cat_scgs_to_one_fasta_aa.output,
        headers = rules.get_headers.output.headers
    output:
        fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_filtered.faa")
    threads: M.T('anvi_script_reformat_fasta')
    shell:
        "anvi-script-reformat-fasta {input.faa} \
                              -I {input.headers} \
                              -o {output.fasta} >> {log} 2>&1"

rule cat_misc_data_to_one_file:
    """
    Cat all sequence misc data from separate samples in one tsv.

    FIXME: The header is removed when concatenating all the files together. THis
    is done because otherwise the headers will be printed multiple times throughout
    the file. To avoid this I remove the header line before concatentating. In the
    next rule I add the header back to the top of the line... THis is not elegant and
    sucks.
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{{ribosomal_protein_name}}_estimate_scg_taxonomy_results_ed.tsv"), sample_name = M.names_list)
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        "cat {input} >> {output}"


rule add_header_to_misc_file:
    """
    FIXME: replace with sed when running on linux

    # grep -v "header" {input} | sed -i '1s|^|header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n|' > {output}
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: rules.cat_misc_data_to_one_file.output
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        """
        echo -e "new_header\tsample\tcontig_db_type\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species" > {output}

        cat {input} >> {output}
        """

# Initial alignment, trim, and removal of sequences with 50% gaps or more
rule align_muscle:
    """Initial alignment with muscle"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_{ribosomal_protein_name}.log")
	input: rules.filter_for_aa_seqs.output.fasta
	output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.faa")
	threads: M.T('align_muscle')
	shell:
		"muscle -in {input} \
				    -out {output} \
            -maxiters 2 \
            -verbose 2> {log}"


# FIXME: odseq in R will only accept a MSA object from the package MSA
# The MSA package does have muscle as an option for the alignment 
# algorithm to use but this would mean a massive MSA calculation in R
# NOT in the mood to figure our the ramifications of this at the moment
# but I have a feeling that this will really slow down the workflow.
# Now that I have the --gappyout parameter in trimal, I should be 
# doing a smarter job at trimming and subsequently removing sequences that 
# have a high percentage of gaps. 
# rule remove_outlier_seqs_odseq:
#     """Removing sequences that have > 50% gaps"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_odseq.fasta")
#     threads: M.T('remove_gaps')
#     script:
#         "scripts/odseq_remove_outliers.R --msa {input} --output"

rule trim_alignment:
    """Trim alignment with trimal"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_{ribosomal_protein_name}.log")
    input: rules.align_muscle.output
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed.faa")
    params:
        gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
        gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
        additional_params = M.get_param_value_from_config(['trim_alignment', 'additional_params'])
    shell:
        'trimal -in {input} \
                -out {output} \
                {params.gappyout} \
                {params.additional_params} 2> {log}'

rule remove_sequences_with_X_percent_gaps:
    """Removing sequences that have Z > X% gaps"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
    input: rules.trim_alignment.output
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
    params:
        seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_01.tsv"),
        max_percentage_gaps=M.get_param_value_from_config(['remove_sequences_with_X_percent_gaps', '--max-percentage-gaps'])
    threads: M.T('remove_gaps')
	shell:
		"anvi-script-reformat-fasta {input} \
									-o {output} \
									--max-percentage-gaps {params.max_percentage_gaps} \
									--export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# Remove sequences that have an outlier set of gaps in a sequences
# - this step further refines the MSA by removing more sequences that have too many gaps.
# to make this smarter, we will rely on the standard outlier threshold of 1.5*IQR and remove any
# sequences with more gaps than that. To accomplish this the following steps will be taken:
# * Get the distribution of gaps counts per sequences
# * calculate the outlier threshold 1.5*IQR
# * remove sequences greater than that threshold

# STEPS FOR FILTERING OUT SEQUENCING BASED ON PERCENT GAPS
# KEEPPPPP MAY WANT TO INCLUDE LATER

# rule get_gap_count_distribution:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "get_gap_count_distribution_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
#     output: seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02.tsv")
#     params: tmp_asdf=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02_tmp"),
#             seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02")
#     threads: M.T('get_gap_count_distribution')
#     shell:
#         "anvi-script-reformat-fasta {input} \
#                                     -o {params.tmp_asdf} \
#                                     --export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# rule filter_out_outlier_sequences:
#     """Filter out sequences with more gaps than the 1.5*IQR of the gap distribution across all sequences"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "filter_out_outlier_sequences_{ribosomal_protein_name}.log")
#     input:
#         tsv = rules.get_gap_count_distribution.output.seq_counts_tsv,
#         fasta = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
#     params:
#         gap_threshold = M.get_param_value_from_config(['MSA_gap_threshold'])
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
#     threads: M.T('filter_out_outlier_sequences')
#     script:
#         "scripts/filter_gap_count_outlier_sequence.py"


rule count_num_sequences_filtered:
    """
    This rule will count the number of SCG sequences filtered at each step of the workflow.
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "count_num_sequences_filtered_{ribosomal_protein_name}.log")
    input:
        step1 = rules.cat_scgs_to_one_fasta_nt.output,
        step2 = rules.cluster_X_percent_sim_mmseqs.output,
        step3 = rules.remove_sequences_with_X_percent_gaps.output
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_STATS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_stats.tsv")
    threads: M.T('trim_alignment_2')
    shell:
        """
        # Headers (only echos do stdout and I'm not sure why, also this line need to be included for this rule to work... go ahead comment it out and see what happens!)
        echo -e  "Rule_name\tNum_sequences\trel_path\n > {output}"

        # How many SCGs (e.g. Ribosomal_L16) did we recruit across all input data (genomes and metagenomes)?
        step1=$(grep -c '>' {input.step1})
        echo -e "cat_scgs_to_one_fasta_nt\t$step1\t{input.step1}\n" > {output}

        # How many SCGs do we have after we cluster them at the nt level and pick representatives?
        step2=$(grep -c '>' {input.step2})
        echo -e "cluster_X_percent_sim_mmseqs\t$step2\t{input.step2}\n" >> {output}

        # How many seqs are in the NR set?
        step3=$(grep -c '>' {input.step3})
        echo -e "remove_sequences_with_X_percent_gaps\t$step3\t{input.step3}\n" >> {output}

        # ACTUALLY adding column names here
        echo -e "Rule_name\tNum_sequences\trel_path\n$(cat {output})" > {output}
        """

# Here we add metadata that indentifies if there were SCGs from isolate genomes
# that were clustered with metagenome derived SCGs but were not selected as the
# representative. I think users will want to know where their isolate genomes SCGs
# ended up so this is for them.

if M.external_genomes:
    rule add_misc_layer_to_detect_if_genomic_SCG_in_cluster:
        """
        """
        version: 1.0
        input:
            misc_data = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
            final_list_of_sequences_for_tree_calculation = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
        output:
            misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
        params:
            external_genomes = M.external_genomes_names_list,
            cluster_rep_index = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_cluster.tsv")
        threads: M.T('join_renamed_fasta_with_misc_data')
        script:
            "scripts/add_layer_for_reps.py"

else:
    rule add_misc_layer_to_detect_if_genomic_SCG_in_cluster:
        """
        """
        version: 1.0
        input:
            misc_data = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
            final_list_of_sequences_for_tree_calculation = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
        output:
            misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
        params:
            cluster_rep_index = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_cluster.tsv")
        threads: M.T('join_renamed_fasta_with_misc_data')
        script:
            "scripts/add_layer_for_reps_no_external_genomes.py"

rule get_headers_for_mapping:
    """Subset the SCG sequence headers that will be used for read recruitment later"""
    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        fasta = rules.remove_sequences_with_X_percent_gaps.output
    output:
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_headers_for_mapping.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script: "scripts/get_sequence_headers_for_mapping.py"

rule filter_for_nt_seqs_for_mapping:
    """Filter for SCG NT sequences what will be used for read recruitment later"""

    version: 1.0
    input:
        fasta = rules.cat_scgs_to_one_fasta_nt.output,
        headers = rules.get_headers_for_mapping.output.headers
    output:
        nt_for_mapping = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_scgs_for_mapping.fna")
    threads: M.T('join_renamed_fasta_with_misc_data')
    shell:
        "anvi-script-reformat-fasta {input.fasta} \
                                    -o {output} \
                                    -I {input.headers}"

rule make_fasta_txt:
    """Output fasta.txt that will be used with the metagenomics workflow"""

    version: 1.0
    output:
        os.path.join("RIBO_PHYLO_WORKFLOW", "fasta.txt")
    threads: M.T('join_renamed_fasta_with_misc_data')
    run:
        fastas = [os.path.join("..", dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], r + "/" + r + '_scgs_for_mapping.fna') for r in M.SCG_protein_list]
        external_gene_calls = [os.path.join("..", dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], r + "/" + r + '_external_gene_calls_all_renamed.tsv') for r in M.SCG_protein_list]

        list_of_strings = ['\t'.join(t) + '\n' for t in zip(M.SCG_protein_list, fastas, external_gene_calls)]

        shell('echo -e "name\tpath\texternal_gene_calls" > {output}')
        shell('echo -n "%s" >> {output}' % ''.join(list_of_strings))

if M.run_iqtree == True:
  rule iqtree:
      """Calculate a phylogenetic tree using iqtree"""

      version: 1.0
      log: os.path.join(dirs_dict['LOGS_DIR'], "iqtree_{ribosomal_protein_name}.log")
      input: rules.remove_sequences_with_X_percent_gaps.output
      output: os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}.iqtree")
      params:
          outfile=os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}"),
          model = M.get_param_value_from_config(['iqtree', '-m']),
          additional_params = M.get_param_value_from_config(['iqtree', 'additional_params'])
      threads: M.T('iqtree')
      shell:
          "iqtree -s {input} \
                  -nt AUTO \
                  -m {params.model} \
                  -pre {params.outfile} \
                  -T AUTO \
                  {params.additional_params} >> {log} 2>&1"

elif M.run_fasttree == True:
  rule fasttree:
      """Want to go faster?? Then Fasttree"""

      version: 1.0
      log: os.path.join(dirs_dict['LOGS_DIR'], "fasttree_{ribosomal_protein_name}.log")
      input: rules.remove_sequences_with_X_percent_gaps.output
      output: os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}.nwk")
      params:
          outfile=os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}"),
          model = M.get_param_value_from_config(['fasttree', '-m']),
          additional_params = M.get_param_value_from_config(['fasttree', 'additional_params'])
      threads: M.T('fasttree')
      shell:
          "FastTree -fastest {input} > {output}"