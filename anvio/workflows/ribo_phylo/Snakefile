# -*- coding: utf-8

import argparse
import os
import pandas as pd

import anvio
import anvio.utils as u
import anvio.workflows as w

from anvio.errors import ConfigError
from anvio.workflows.ribo_phylo import RibosomalPhylogeneticsWorkflow

__author__ = "Matthew S. Schechter"
__copyright__ = "Copyright 2017, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Matthew S. Schechter"
__email__ = "mschechter@uchicago.edu"


slave_mode = False if 'workflows/ribo_phylo' in workflow.included[0] else True

# if not slave_mode:
#     # it is important that this comes before the include statement since
#     # M is defined here and will also be used in the contigs workflow
#     M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
#     M.init()
#     dirs_dict = M.dirs_dict
#     # in order to generate the contigs databases we include the snakefile
#     # for the generation of contigs databases
#     include: w.get_workflow_snake_file_path('metagenomics')

M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
M.init()

dirs_dict = M.dirs_dict


# NOTE: user should run workflow until the rule get_gap_count_distribution. This can be done by running the command:
# $ anvi-run-workflow -w ribo_phylo -c config.json -A --until cat_misc_data_to_one_file
# This will allow the user to explore the gap distribution of the SCG MSA and decide an appropriate threshold. Currently,
# the threshold is fixed at 1.5*IQR. After the user has decided on a threshold they can add it to the config file

rule ribo_phylo_workflow_target_rule:
    input: M.target_files

rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins_aa:
    """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input:
        expand(os.path.join("{dataset}", "{{sample_name}}-contigs.db"), dataset=M.names_dirs)
    output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.faa")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
	shell: "anvi-get-sequences-for-hmm-hits -c {input} \
                                            {params.hmm_source} \
                                           --get-aa-sequences \
                                           --gene-name {wildcards.ribosomal_protein_name} \
                                           -o {output} 2> {log}"

rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins_nt:
    """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input:
        expand(os.path.join("{dataset}", "{{sample_name}}-contigs.db"), dataset=M.names_dirs)
    output:
        fna = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
    shell: "anvi-get-sequences-for-hmm-hits -c {input} \
                                           {params.hmm_source} \
                                           --gene-name {wildcards.ribosomal_protein_name} \
                                           -o {output} 2> {log}"

rule anvi_estimate_scg_taxonomy_for_ribosomal_proteins:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input:
        expand(os.path.join("{dataset}", "{{sample_name}}-contigs.db"), dataset=M.names_dirs)
    output:
        taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
    params:
    threads: M.T('anvi_estimate_scg_taxonomy_for_ribosomal_proteins')
    message: "I cant put messages... this might be useful!... Launching rule: {rule}"
    run:
        shell('anvi-estimate-scg-taxonomy -c {input} \
                                          --metagenome-mode \
                                          --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
                                          -o {output} 2> {log}')

rule simplify_names_from_scg_hits_nt:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    output:
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.fna"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_nt.txt")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --prefix {wildcards.sample_name} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

rule simplify_names_from_scg_hits_aa:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", '{sample_name}_{ribosomal_protein_name}_hmm_hits.faa')
    output:
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.faa"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_aa.txt")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --prefix {wildcards.sample_name} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

rule join_renamed_fastas_with_taxonomy_data_text:
    """Add simplified fasta headers to the misc data file"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "join_renamed_fasta_with_misc_data_{sample_name}_{ribosomal_protein_name}.log")
    input:
        taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_nt.txt"),
    output:
        misc_data_final = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results_ed.tsv")
    params:
        external_genomes = M.external_genomes
    threads: M.T('join_renamed_fasta_with_misc_data')
    # script:
    #     "scripts/rename_fasta_headers.py"
    run:
        if M.mode == "both":
            if wildcards.sample_name in M.external_genomes_names_list:

                from Bio import SeqIO

                import pandas as pd
                import numpy as np
                import glob
                import os.path

                # Import fasta header index
                #----------------------------
                reformat_report = pd.read_csv(input.report_file, \
                                  sep="\t", \
                                  index_col=None,
                                  names=['new_header', 'old_header'])

                taxonomy = pd.read_csv(input.taxonomy, \
                                  sep="\t", \
                                  index_col=None)

                # Clean
                #------
                taxonomy = taxonomy.rename(columns = {'scg_name': 'sequence_name'})

                reformat_report['gene_callers_id'] = reformat_report['old_header'].str.split("gene_callers_id:|\|start:", expand=True)[1].astype(int)
                reformat_report['sequence_name'] = wildcards.ribosomal_protein_name + '_' + reformat_report['gene_callers_id'].map(str)
                reformat_report['sample'] = wildcards.sample_name
                reformat_report['contig_db_type'] = 'genome' # here is where the contig_db_type categorical variable get's set, not very fancy but it works

                misc_new_headers_df = reformat_report.merge(taxonomy, on="sequence_name", how="left")[['new_header', 'sample', 'contig_db_type', 't_domain', 't_phylum', 't_order', 't_family', 't_genus', 't_species']]

                # Export
                #------------------------------------------------------------------
                misc_new_headers_df.to_csv(output.misc_data_final, \
                           sep="\t", \
                           index=None, \
                           na_rep="NA", \
                           header=False)

            if wildcards.sample_name in M.metagenomes_name_list:

                from Bio import SeqIO

                import pandas as pd
                import numpy as np
                import glob
                import os.path

                # Import fasta header index
                #----------------------------
                reformat_report = pd.read_csv(input.report_file, \
                                  sep="\t", \
                                  index_col=None,
                                  names=['new_header', 'old_header'])

                taxonomy = pd.read_csv(input.taxonomy, \
                                  sep="\t", \
                                  index_col=None)

                # Clean
                #------
                taxonomy = taxonomy.rename(columns = {'scg_name': 'sequence_name'})

                reformat_report['gene_callers_id'] = reformat_report['old_header'].str.split("gene_callers_id:|\|start:", expand=True)[1].astype(int)
                reformat_report['sequence_name'] = wildcards.ribosomal_protein_name + '_' + reformat_report['gene_callers_id'].map(str)
                reformat_report['sample'] = wildcards.sample_name
                reformat_report['contig_db_type'] = 'metagenome' # here is where the contig_db_type categorical variable get's set, not very fancy but it works

                misc_new_headers_df = reformat_report.merge(taxonomy, on="sequence_name", how="left")[['new_header', 'sample', 'contig_db_type', 't_domain', 't_phylum', 't_order', 't_family', 't_genus', 't_species']]

                # Export
                #------------------------------------------------------------------
                misc_new_headers_df.to_csv(output.misc_data_final, \
                           sep="\t", \
                           index=None, \
                           na_rep="NA", \
                           header=False)

        if M.mode == "external_genomes":

            if wildcards.sample_name in M.external_genomes_names_list:

                from Bio import SeqIO

                import pandas as pd
                import numpy as np
                import glob
                import os.path

                # Import fasta header index
                #----------------------------
                reformat_report = pd.read_csv(input.report_file, \
                                  sep="\t", \
                                  index_col=None,
                                  names=['new_header', 'old_header'])

                taxonomy = pd.read_csv(input.taxonomy, \
                                  sep="\t", \
                                  index_col=None)

                # Clean
                #------
                taxonomy = taxonomy.rename(columns = {'scg_name': 'sequence_name'})

                reformat_report['gene_callers_id'] = reformat_report['old_header'].str.split("gene_callers_id:|\|start:", expand=True)[1].astype(int)
                reformat_report['sequence_name'] = wildcards.ribosomal_protein_name + '_' + reformat_report['gene_callers_id'].map(str)
                reformat_report['sample'] = wildcards.sample_name
                reformat_report['contig_db_type'] = 'genome' # here is where the contig_db_type categorical variable get's set, not very fancy but it works

                misc_new_headers_df = reformat_report.merge(taxonomy, on="sequence_name", how="left")[['new_header', 'sample', 'contig_db_type', 't_domain', 't_phylum', 't_order', 't_family', 't_genus', 't_species']]

                # Export
                #------------------------------------------------------------------
                misc_new_headers_df.to_csv(output.misc_data_final, \
                           sep="\t", \
                           index=None, \
                           na_rep="NA", \
                           header=False)

        if M.mode == "metagenomes":
            if wildcards.sample_name in M.metagenomes_name_list:

                from Bio import SeqIO

                import pandas as pd
                import numpy as np
                import glob
                import os.path

                # Import fasta header index
                #----------------------------
                reformat_report = pd.read_csv(input.report_file, \
                                  sep="\t", \
                                  index_col=None,
                                  names=['new_header', 'old_header'])

                taxonomy = pd.read_csv(input.taxonomy, \
                                  sep="\t", \
                                  index_col=None)

                # Clean
                #------
                taxonomy = taxonomy.rename(columns = {'scg_name': 'sequence_name'})

                reformat_report['gene_callers_id'] = reformat_report['old_header'].str.split("gene_callers_id:|\|start:", expand=True)[1].astype(int)
                reformat_report['sequence_name'] = wildcards.ribosomal_protein_name + '_' + reformat_report['gene_callers_id'].map(str)
                reformat_report['sample'] = wildcards.sample_name
                reformat_report['contig_db_type'] = 'genome' # here is where the contig_db_type categorical variable get's set, not very fancy but it works

                misc_new_headers_df = reformat_report.merge(taxonomy, on="sequence_name", how="left")[['new_header', 'sample', 'contig_db_type', 't_domain', 't_phylum', 't_order', 't_family', 't_genus', 't_species']]

                # Export
                #------------------------------------------------------------------
                misc_new_headers_df.to_csv(output.misc_data_final, \
                           sep="\t", \
                           index=None, \
                           na_rep="NA", \
                           header=False)


rule cat_scgs_to_one_fasta_nt:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: 
        fasta = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_hmm_hits_renamed.fna"), sample_names = M.names_list, ribosomal_protein_names = M.Ribosomal_protein_list),
        # fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{{sample_name}}", "{{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.fna"),
    output: 
        fasta_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fna"),
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell: 
        "cat {input.fasta} >> {output.fasta_all}"

rule cat_scgs_reformat_files_nt:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: 
        reformat_file = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_reformat_report_nt.txt"), sample_names = M.names_list, ribosomal_protein_names = M.Ribosomal_protein_list),
    output: 
        reformat_file_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat.txt")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell: 
        "cat {input.reformat_file} >> {output.reformat_file_all}"

rule cat_scgs_to_one_fasta_aa:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_hmm_hits_renamed.faa"), sample_names = M.names_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.faa")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output.fasta}"

rule cluster_X_percent_sim_mmseqs:
    """Remove redundant ribosomal sequences with mmseqs"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cluster_90_mmseqs_{ribosomal_protein_name}.log")
    input: rules.cat_scgs_to_one_fasta_nt.output
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
    params:
        output_prefix = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR"),
        mmseqs_tmp = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_tmp"),
        min_seq_id = M.get_param_value_from_config(['remove_redundant_sequences_mmseqs', '--min-seq-id'])
    threads: M.T('remove_redundant_sequences_mmseqs')
    shell:
        "mmseqs easy-cluster {input} \
                             {params.output_prefix} \
                             {params.mmseqs_tmp} \
                             --min-seq-id {params.min_seq_id} >> {log} 2>&1"

rule get_headers:
    """
    """
    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        reps = rules.cluster_X_percent_sim_mmseqs.output,
    output:
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq_headers.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script: "scripts/get_sequence_headers.py"

rule filter_for_aa_seqs:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
    input:
        faa = rules.cat_scgs_to_one_fasta_aa.output,
        headers = rules.get_headers.output.headers
    output:
        fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_filtered.faa")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input.faa} \
                              -I {input.headers} \
                              -o {output.fasta} >> {log} 2>&1"

rule cat_misc_data_to_one_file:
    """
    Cat all sequence misc data from separate samples in one tsv.

    FIXME: The header is removed when concatenating all the files together. THis
    is done because otherwise the headers will be printed multiple times throughout
    the file. To avoid this I remove the header line before concatentating. In the
    next rule I add the header back to the top of the line... THis is not elegant and
    sucks.
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{{ribosomal_protein_name}}_estimate_scg_taxonomy_results_ed.tsv"), sample_name = M.names_list)
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        "cat {input} >> {output}"


rule add_header_to_misc_file:
    """
    CARBON COPY IN CASE I BLOW THIS
    Adding header to misc data file.

    See rule cat_misc_data_to_one_file for why this sucks

    FIXME: replace with sed when running on linux

    # grep -v "header" {input} | sed -i '1s|^|header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n|' > {output}

    FIXME: the tmp misc_data files before *_all_misc_data_final.tsv could be removed from the final output
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: rules.cat_misc_data_to_one_file.output
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        """
        echo -e "new_header\tsample\tcontig_db_type\tt_domain\tt_phylum\tt_order\tt_family\tt_genus\tt_species" > {output}

        cat {input} >> {output}
        """

# Initial alignment, trim, and removal of sequences with 50% gaps or more
rule align_muscle:
    """Initial alignment with muscle"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_{ribosomal_protein_name}.log")
	input: rules.filter_for_aa_seqs.output.fasta
	output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.faa")
	threads: M.T('align_muscle')
	shell:
		"muscle -in {input} \
				-out {output} 2> {log}"


# FIXME: odseq in R will only accept a MSA object from the package MSA
# The MSA package does have muscle as an option for the alignment 
# algorithm to use but this would mean a massive MSA calculation in R
# NOT in the mood to figure our the ramifications of this at the moment
# but I have a feeling that this will really slow down the workflow.
# Now that I have the --gappyout parameter in trimal, I should be 
# doing a smarter job at trimming and subsequently removing sequences that 
# have a high percentage of gaps. 
# rule remove_outlier_seqs_odseq:
#     """Removing sequences that have > 50% gaps"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_odseq.fasta")
#     threads: M.T('remove_gaps')
#     script:
#         "scripts/odseq_remove_outliers.R --msa {input} --output"

rule trim_alignment:
    """trim alignment


    FIXME: rant on ordering of trimming and sequence removal steps, need to think about this deeper, not conclusive:

    I think that trimming twice may not be optimal. Here is my logic:
    Trimal is all about removing MSA positions (columns) that contain a threshold proportion of gaps
    i.e. trimming "horizontally". Positions with a lot of gaps are removed because they are
    phylogenetically uninformative. If we trimm before removing all sequences we might be
    making sequences seem more aligned because we have just removed gaps.

    I think trimming should be the very last step in the MSA curation.
    for example:
    (1) cluster at 100%
    (2) calculate MSA
    (3) remove sequences based on gap distribution (anvi-script-reformat-fasta)
    (4) remove positions with a lot of gaps (trimal)

    Another thing to consider is calculating a tree based on representative sequences from a
    clustered dataset. I already need to do this when I pick representative for the mapping
    steps. Why not just use that set to calculate the tree? Also, the over MSA might be
    higher quality because there is less noise with similar sequences.
    for example:
    (1) cluster at 90%
    (2) calculate MSA
    (3) remove sequences with a lot of gaps (anvi-script-reformat-fasta)
    (4) remove positions with a lot of gaps (trimal)
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_{ribosomal_protein_name}.log")
    input: rules.align_muscle.output
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed.faa")
    params:
        gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
        gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
        additional_params = M.get_param_value_from_config(['trim_alignment', 'additional_params'])
    shell:
        'trimal -in {input} \
                -out {output} \
                {params.gappyout} \
                {params.additional_params} 2> {log}'

rule remove_sequences_with_X_percent_gaps:
    """Removing sequences that have > X% gaps"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
    input: rules.trim_alignment.output
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
    params:
        seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_01.tsv"),
        max_percentage_gaps=M.get_param_value_from_config(['remove_sequences_with_X_percent_gaps', '--max-percentage-gaps'])
    threads: M.T('remove_gaps')
	shell:
		"anvi-script-reformat-fasta {input} \
									-o {output} \
									--max-percentage-gaps {params.max_percentage_gaps} \
									--export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# Remove sequences that have an outlier set of gaps in a sequences
# - this step further refines the MSA by removing more sequences that have too many gaps.
# to make this smarter, we will rely on the standard outlier threshold of 1.5*IQR and remove any
# sequences with more gaps than that. To accomplish this the following steps will be taken:
# * Get the distribution of gaps counts per sequences
# * calculate the outlier threshold 1.5*IQR
# * remove sequences greater than that threshold

# STEPS FOR FILTERING OUT SEQUENCING BASED ON PERCENT GAPS
# KEEPPPPP MAY WANT TO INCLUDE LATER

# rule get_gap_count_distribution:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "get_gap_count_distribution_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
#     output: seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02.tsv")
#     params: tmp_asdf=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02_tmp"),
#             seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02")
#     threads: M.T('get_gap_count_distribution')
#     shell:
#         "anvi-script-reformat-fasta {input} \
#                                     -o {params.tmp_asdf} \
#                                     --export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# rule filter_out_outlier_sequences:
#     """Filter out sequences with more gaps than the 1.5*IQR of the gap distribution across all sequences"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "filter_out_outlier_sequences_{ribosomal_protein_name}.log")
#     input:
#         tsv = rules.get_gap_count_distribution.output.seq_counts_tsv,
#         fasta = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
#     params:
#         gap_threshold = M.get_param_value_from_config(['MSA_gap_threshold'])
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
#     threads: M.T('filter_out_outlier_sequences')
#     script:
#         "scripts/filter_gap_count_outlier_sequence.py"

# rule align_muscle_2:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_2_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     threads: M.T('align_muscle_2')
#     shell:
#         "muscle -in {input} \
#                 -out {output} 2> {log}"

# rule trim_alignment_2:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_2_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
#     params:
#         gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
#         gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
#         additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
#     shell:
#         'trimal -in {input} \
#                 -out {output} \
#                 {params.gappyout} \
#                 {params.additional_params} 2> {log}'

rule count_num_sequences_filtered:
    """
    This rule will count the number of Ribosomal sequences filtered at each step of the workflow.

    FIXME: for some reason and cannot prepend the file with headers and I have no idea why...
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "count_num_sequences_filtered_{ribosomal_protein_name}.log")
    input:
        step1 = rules.cat_scgs_to_one_fasta_nt.output,
        step2 = rules.cluster_X_percent_sim_mmseqs.output,
        step3 = rules.remove_sequences_with_X_percent_gaps.output
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_STATS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_stats.tsv")
    threads: M.T('trim_alignment_2')
    shell:
        """
        # Headers (only echos do stdout and I'm not sure why, also this line need to be included for this rule to work... go ahead comment it out and see what happens!)
        echo -e  "Rule_name\tNum_sequences\trel_path\n > {output}"

        # How many SCGs (e.g. Ribosomal_L16) did we recruit across all input data (genomes and metagenomes)?
        step1=$(grep -c '>' {input.step1})
        echo -e "cat_scgs_to_one_fasta_nt\t$step1\t{input.step1}\n" > {output}

        # How many SCGs do we have after we cluster them at the nt level and pick representatives?
        step2=$(grep -c '>' {input.step2})
        echo -e "cluster_X_percent_sim_mmseqs\t$step2\t{input.step2}\n" >> {output}

        # How many seqs are in the NR set?
        step3=$(grep -c '>' {input.step3})
        echo -e "remove_sequences_with_X_percent_gaps\t$step3\t{input.step3}\n" >> {output}

        # ACTUALLY adding column names here
        echo -e "Rule_name\tNum_sequences\trel_path\n$(cat {output})" > {output}
        """


if M.external_genomes:
    rule add_misc_layer_to_detect_if_genomic_SCG_in_cluster:
        """
        """
        version: 1.0
        input:
            misc_data = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
            final_list_of_sequences_for_tree_calculation = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
        output:
            misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
        params:
            external_genomes = M.external_genomes_names_list,
            cluster_rep_index = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_cluster.tsv")
        threads: M.T('join_renamed_fasta_with_misc_data')
        script:
            "scripts/add_layer_for_reps.py"

else:
    rule add_misc_layer_to_detect_if_genomic_SCG_in_cluster:
        """
        """
        version: 1.0
        input:
            misc_data = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
            final_list_of_sequences_for_tree_calculation = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
        output:
            misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
        params:
            cluster_rep_index = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_cluster.tsv")
        threads: M.T('join_renamed_fasta_with_misc_data')
        script:
            "scripts/add_layer_for_reps_no_external_genomes.py"

rule get_headers_for_mapping:
    """
    """
    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        fasta = rules.remove_sequences_with_X_percent_gaps.output
    output:
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_headers_for_mapping.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script: "scripts/get_sequence_headers_for_mapping.py"

rule filter_for_nt_seqs_for_mapping:
    """
    """

    version: 1.0
    input:
        fasta = rules.cat_scgs_to_one_fasta_nt.output,
        headers = rules.get_headers_for_mapping.output.headers
    output:
        nt_for_mapping = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_scgs_for_mapping.fna")
    threads: M.T('join_renamed_fasta_with_misc_data')
    shell:
        "anvi-script-reformat-fasta {input.fasta} \
                                    -o {output} \
                                    -I {input.headers}"

# rule calculate_tree:
#     """Calculate a phylogenetic tree using iqtree"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "calculate_tree_{ribosomal_protein_name}.log")
#     input: rules.remove_sequences_with_X_percent_gaps.output
#     output: os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}.iqtree")
#     params:
#         outfile=os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}"),
#         model = M.get_param_value_from_config(['calculate_tree', '-m']),
#         additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
#     threads: M.T('calculate_tree')
#     shell:
#         "iqtree -s {input} \
#                 -nt AUTO \
#                 -m {params.model} \
#                 -pre {params.outfile} \
#                 {params.additional_params} >> {log} 2>&1"

rule calculate_tree_fast:
    """Calculate a phylogenetic tree using iqtree"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "fasttree_{ribosomal_protein_name}.log")
    input: rules.remove_sequences_with_X_percent_gaps.output
    output: os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}.nwk")
    params:
        outfile=os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}"),
        model = M.get_param_value_from_config(['calculate_tree', '-m']),
        additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
    threads: M.T('calculate_tree')
    shell:
        "FastTree -fastest {input} > {output}"
