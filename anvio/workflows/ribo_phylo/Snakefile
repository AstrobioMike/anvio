# -*- coding: utf-8

import argparse
import os
import pandas as pd

import anvio
import anvio.utils as u
import anvio.workflows as w

from anvio.errors import ConfigError
from anvio.workflows.ribo_phylo import RibosomalPhylogeneticsWorkflow

__author__ = "Matthew S. Schechter"
__copyright__ = "Copyright 2017, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Matthew S. Schechter"
__email__ = "mschechter@uchicago.edu"


slave_mode = False if 'workflows/ribo_phylo' in workflow.included[0] else True

# if not slave_mode:
#     # it is important that this comes before the include statement since
#     # M is defined here and will also be used in the contigs workflow
#     M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
#     M.init()
#     dirs_dict = M.dirs_dict
#     # in order to generate the contigs databases we include the snakefile
#     # for the generation of contigs databases
#     include: w.get_workflow_snake_file_path('metagenomics')

M = RibosomalPhylogeneticsWorkflow(argparse.Namespace(config=config))
M.init()

dirs_dict = M.dirs_dict


# NOTE: user should run workflow until the rule get_gap_count_distribution. This can be done by running the command:
# $ anvi-run-workflow -w ribo_phylo -c config.json -A --until cat_misc_data_to_one_file
# This will allow the user to explore the gap distribution of the SCG MSA and decide an appropriate threshold. Currently,
# the threshold is fixed at 1.5*IQR. After the user has decided on a threshold they can add it to the config file

rule ribo_phylo_workflow_target_rule:
    input: M.target_files
    # input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{ribosomal_protein_names}_mmseqs_NR_rep_seq.fasta"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    # input: expand(os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_names}/{ribosomal_protein_names}_all.fasta"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list)

rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins_aa:
    """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input:
        expand(os.path.join("{dataset}", "{{sample_name}}.db"), dataset=M.names_dirs)
    output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.faa")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
	shell: "anvi-get-sequences-for-hmm-hits -c {input} \
                                       {params.hmm_source} \
                                       --get-aa-sequences \
                                       --gene-name {wildcards.ribosomal_protein_name} \
                                       -o {output} 2> {log}"

rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins_nt:
    """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input:
        expand(os.path.join("{dataset}", "{{sample_name}}.db"), dataset=M.names_dirs)
    output:
        fna = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    params:
        hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
    shell: "anvi-get-sequences-for-hmm-hits -c {input} \
                                       {params.hmm_source} \
                                       --gene-name {wildcards.ribosomal_protein_name} \
                                       -o {output} 2> {log}"

rule anvi_estimate_scg_taxonomy_for_ribosomal_proteins:
    """Retrieve SCG taxonomy from extracted ribosomal proteins"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    input:
        expand(os.path.join("{dataset}", "{{sample_name}}.db"), dataset=M.names_dirs)
    output:
        taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
    params:
    threads: M.T('anvi_estimate_scg_taxonomy_for_ribosomal_proteins')
    message: "I cant put messages... this might be useful!... Launching rule: {rule}"
    run:
        shell('anvi-estimate-scg-taxonomy -c {input} \
                                        --metagenome-mode \
                                        --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
                                        -o {output} 2> {log}')
        # if M.mode == 'metagenomes':
        #     if wildcards.sample_name in M.metagenomes_name_list:
        #         shell('anvi-estimate-scg-taxonomy -c {input} \
        #                                 --metagenome-mode \
        #                                 --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
        #                                 -o {output} 2> {log}')

        # if M.mode == 'external_genomes':
        #     if wildcards.sample_name in M.external_genomes_names_list:
        #         shell('anvi-estimate-scg-taxonomy -c {input} \
        #                                 -o {output} 2> {log}')

        # if M.mode == 'both':
        #     if wildcards.sample_name in M.external_genomes_names_list:
        #         shell('anvi-estimate-scg-taxonomy -c {input} \
        #                                 -o {output} 2> {log}')

        #     if wildcards.sample_name in M.metagenomes_name_list:
        #         shell('anvi-estimate-scg-taxonomy -c {input} \
        #                                 --metagenome-mode \
        #                                 --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
        #                                 -o {output} 2> {log}')
# if M.metagenomes:
#     rule anvi_estimate_scg_taxonomy_for_ribosomal_proteins:
#         """Retrieve SCG taxonomy from extracted ribosomal proteins"""

#         version: 1.0
#         log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
#         input: os.path.join(M.metagenomes_contig_dir, "{sample_name}-contigs.db")
#         output:
#             taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
#         params:
#             metagenome_mode = M.get_rule_param('anvi_estimate_scg_taxonomy_for_ribosomal_proteins', '--metagenome-mode')
#         threads: M.T('anvi_estimate_scg_taxonomy_for_ribosomal_proteins')
#         message: "I cant put messages... this might be useful!... Launching rule: {rule}"
#         shell:
#             "anvi-estimate-scg-taxonomy -c {input} \
#                                         {params.metagenome_mode} \
#                                         --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
#                                         -o {output} 2> {log}"
# If the user provides a list of isolate genomes
# if M.external_genomes:
    # rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins_external_genomes_nt:
    #     """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    #     version: 1.0
    #     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    #     input: os.path.join(M.external_genomes_contig_dir, "{sample_name}-contigs.db")
    #     output:
    #         fna = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    #     params:
    #         hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    #     threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
    #     shell: "anvi-get-sequences-for-hmm-hits -c {input} \
    #                                        {params.hmm_source} \
    #                                        --gene-name {wildcards.ribosomal_protein_name} \
    #                                        -o {output} 2> {log}"

    # rule anvi_get_sequences_for_hmm_hits_ribosomal_proteins_external_genomes_aa:
    #     """Extract all ribosomal proteins listed in Ribosomal_protein_list.txt from metagenomes and genomes in samples.txt."""

    #     version: 1.0
    #     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_hmm_hits_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
    #     input: os.path.join(M.external_genomes_contig_dir, "{sample_name}-contigs.db")
    #     output: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.faa")
    #     params:
    #         hmm_source = M.get_rule_param('anvi_get_sequences_for_hmm_hits_ribosomal_proteins', '--hmm-source')
    #     threads: M.T('anvi_get_sequences_for_hmm_hits_ribosomal_proteins')
    #     shell: "anvi-get-sequences-for-hmm-hits -c {input} \
    #                                        {params.hmm_source} \
    #                                        --get-aa-sequences \
    #                                        --gene-name {wildcards.ribosomal_protein_name} \
    #                                        -o {output} 2> {log}"

# if M.external_genomes:
#     rule anvi_estimate_scg_taxonomy_for_ribosomal_proteins_external_genomes:
#         """Retrieve SCG taxonomy from extracted ribosomal proteins"""

#         version: 1.0
#         log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_estimate_scg_taxonomy_for_ribosomal_proteins_{sample_name}_{ribosomal_protein_name}.log")
#         input: os.path.join(M.external_genomes_contig_dir, "{sample_name}-contigs.db")
#         output:
#             taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv")
#         params:
#             metagenome_mode = M.get_rule_param('anvi_estimate_scg_taxonomy_for_ribosomal_proteins', '--metagenome-mode')
#         threads: M.T('anvi_estimate_scg_taxonomy_for_ribosomal_proteins')
#         message: "I cant put messages... this might be useful!... Launching rule: {rule}"
#         shell:
#             "anvi-estimate-scg-taxonomy -c {input} \
#                                         {params.metagenome_mode} \
#                                         --scg-name-for-metagenome-mode {wildcards.ribosomal_protein_name} \
#                                         -o {output} 2> {log}"

rule simplify_names_from_scg_hits_nt:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits.fna")
    output:
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.fna"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_nt.txt")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --prefix {wildcards.sample_name} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"

rule simplify_names_from_scg_hits_aa:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{sample_name}_{ribosomal_protein_name}.log")
    input: os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", '{sample_name}_{ribosomal_protein_name}_hmm_hits.faa')
    output:
        fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.faa"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_aa.txt")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input} \
                              --simplify-names \
                              --prefix {wildcards.sample_name} \
                              --report-file {output.report_file} \
                              -o {output.fasta} >> {log} 2>&1"


rule join_renamed_fastas_with_taxonomy_data_text:
    """Add simplified fasta headers to the misc data file"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "join_renamed_fasta_with_misc_data_{sample_name}_{ribosomal_protein_name}.log")
    input:
        taxonomy = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results.tsv"),
        report_file = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reformat_report_nt.txt"),
    output:
        misc_data_final = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_estimate_scg_taxonomy_results_ed.tsv")
    threads: M.T('join_renamed_fasta_with_misc_data')
    script:
        "scripts/rename_fasta_headers_no_external_genomes.py"


# rule filter_for_scg_sequences_and_metadata:
#     """Remove sequences that do not have SCG taxonomy"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "filter_for_scg_sequences_and_metadata_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         SCG_taxonomy = rules.anvi_estimate_scg_taxonomy_for_ribosomal_proteins.output.taxonomy,
#         fasta = rules.anvi_get_sequences_for_hmm_hits_ribosomal_proteins_nt.output.fna
#     output:
#         fasta_filtered = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fna"),
#         misc_data = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_misc_data.tsv"),
#         gene_callers_ids = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids.tsv")

#     threads: M.T('filter_for_scg_sequences_and_metadata')
#     script:
#         "scripts/filter_for_scg_sequences_and_metadata.py"

# rule count_sequences_filtered_by_SCG_taxonomy:
#     """
#     Count the SCG sequences that are not found to have a taxonomy assignment via SCG_taxonomy.
#     This is important because SCG taxonomy is the first filtering step to removing SCG sequences
#     and may need to be considered down the line.
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "filter_for_scg_sequences_and_metadata_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         first_fasta = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{ribosomal_protein_names}_hmm_hits.fna"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list),
#         fasta_after_SCG = expand(os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_names}", "{sample_names}_{ribosomal_protein_names}.fna"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list),
#         # first_fasta = rules.anvi_get_sequences_for_hmm_hits_ribosomal_proteins_nt.output.fna,
#         # fasta_after_SCG = rules.filter_for_scg_sequences_and_metadata.output.fasta_filtered
#     output:
#         tsv = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_seq_counts.tsv")
#     threads: M.T('filter_for_scg_sequences_and_metadata')
#     shell:
#         """
#         # Headers
#         echo -e "Description\tRule_name\tNum_sequences\n > {output}"

#         # Rule: anvi_reformat_fasta_ribosomal_protein_file
#         step1=$(grep -c '>' {input.first_fasta})
#         step2=$(grep -c '>' {input.fasta_after_SCG})
#         echo -e "{wildcards.ribosomal_protein_name}\tbefore_SCG\t$step1\n" >> {output}
#         echo -e "{wildcards.ribosomal_protein_name}\tafter_SCG\t$step2\n" >> {output}
#         """

# rule anvi_get_sequences_for_gene_calls:
#     """Get nucleotide sequences for gene calls

#         Here we start the mapping section of the workflow by getting the nucleotide fastas
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_gene_calls_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         contigsDBs = os.path.join(M.contig_dir, "{sample_name}-contigs.db"),
#         gene_callers_ids = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids.tsv")
#     output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fna")
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     shell:
#         """
#         anvi-get-sequences-for-gene-calls -c {input.contigsDBs} \
#                                     --gene-caller-ids {input.gene_callers_ids} \
#                                     -o {output} 2> {log}
#         """


# rule rename_gene_calls:
#     """Retrieve SCG taxonomy from extracted ribosomal proteins"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "rename_gene_calls_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         fna = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}.fna"),
#         report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt")
#     output:
#         fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_renamed.fna")
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     script:
#         "scripts/rename_fasta_headers.py"

# rule cat_SCG_NT_to_one_fasta:
#     """DOC string
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "cat_SCG_NT_to_one_fasta_{ribosomal_protein_name}.log")
#     input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{sample_names}", "{sample_names}_{ribosomal_protein_names}_renamed.fna"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list)
#     output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all.fna")
#     threads: M.T('cat_ribo_proteins_to_one_fasta')
#     shell:
#         "cat {input} >> {output}"

rule cat_scgs_to_one_fasta_nt:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: 
        fasta = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_hmm_hits_renamed.fna"), sample_names = M.names_list, ribosomal_protein_names = M.Ribosomal_protein_list),
        # fasta = os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{{sample_name}}", "{{sample_name}_{ribosomal_protein_name}_hmm_hits_renamed.fna"),
    output: 
        fasta_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fna"),
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell: 
        "cat {input.fasta} >> {output.fasta_all}"

rule cat_scgs_reformat_files_nt:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: 
        reformat_file = expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_reformat_report_nt.txt"), sample_names = M.names_list, ribosomal_protein_names = M.Ribosomal_protein_list),
    output: 
        reformat_file_all = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat.txt")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell: 
        "cat {input.reformat_file} >> {output.reformat_file_all}"



# rule simplify_names:
#     """Clean up fasta headers for tree calculation."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
#     input: rules.cat_scgs_to_one_fasta_nt.output
#     output:
#         fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_renamed.fasta"),
#         report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt")
#     threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
#     shell:
#         "anvi-script-reformat-fasta {input} \
#                               --simplify-names \
#                               --report-file {output.report_file} \
#                               -o {output.fasta} >> {log} 2>&1"

rule cat_scgs_to_one_fasta_aa:
    """
    Cat all ribosomal sequences from seperate metagenomes into one fasta
    
    FIXME: the "{ribosomal_protein_name}/{ribosomal_protein_name}_all.fasta" can be removed because only the renamed
    version of the fasta file is referenced for the rest of the workflow
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_DIR'], "{sample_names}", "{sample_names}_{{ribosomal_protein_name}}_hmm_hits_renamed.faa"), sample_names = M.names_list, ribosomal_protein_names = M.Ribosomal_protein_list)
    output: fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all.faa")
    threads: M.T('cat_ribo_proteins_to_one_fasta')
    shell:
        "cat {input} >> {output.fasta}"

# rule rename_aa_seqs:
#     """Retrieve SCG taxonomy from extracted ribosomal proteins"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "asdf_{ribosomal_protein_name}.log")
#     input:
#         faa = rules.cat_scgs_to_one_fasta_aa.output.fasta,
#         report_file = rules.cat_scgs_reformat_files_nt.output
#     output:
#         fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_filtered_renamed.faa")
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     script:
#         "scripts/rename_fasta_headers.py"


rule cluster_X_percent_sim_mmseqs:
    """Remove redundant ribosomal sequences with mmseqs"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cluster_90_mmseqs_{ribosomal_protein_name}.log")
    input: rules.cat_scgs_to_one_fasta_nt.output
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
    params:
        output_prefix = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR"),
        mmseqs_tmp = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_tmp"),
        min_seq_id = M.get_param_value_from_config(['remove_redundant_sequences_mmseqs', '--min-seq-id'])
    threads: M.T('remove_redundant_sequences_mmseqs')
    shell:
        "mmseqs easy-cluster {input} \
                             {params.output_prefix} \
                             {params.mmseqs_tmp} \
                             --min-seq-id {params.min_seq_id} >> {log} 2>&1"

rule get_headers:
    """
    """
    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        reps = rules.cluster_X_percent_sim_mmseqs.output,
    output:
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_rep_seq_headers.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script: "scripts/get_sequence_headers.py"

rule filter_for_aa_seqs:
    """Clean up fasta headers for tree calculation."""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
    input:
        faa = rules.cat_scgs_to_one_fasta_aa.output,
        headers = rules.get_headers.output.headers
    output:
        fasta = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_filtered.faa")
    threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
    shell:
        "anvi-script-reformat-fasta {input.faa} \
                              -I {input.headers} \
                              -o {output.fasta} >> {log} 2>&1"



# rule get_gene_callers_ids_for_mapping:
#     """
#     Retrieve the gene-callers-ids from the representative sequences for anvi_get_sequences_for_gene_calls
#     to extract the sequences with 150 nt leeway upstream and downstream
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
#     input:
#         reps = os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta"),
#         report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}","{ribosomal_protein_name}_reformat_report_all.txt")
#     output:
#          report_file_filtered = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_reformat_report_msa2.txt")
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     script:
#     "scripts/get_gene_caller_ids_for_mapping.py"

# rule anvi_get_gene_caller_ids_for_reps:
#     """Retrieve SCG taxonomy from extracted ribosomal proteins"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_gene_calls_reps_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         gene_callers_ids = os.path.join(dirs_dict['FILTERED_RIBO_PROTEINS_SEQUENCES_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids.tsv"),
#         reformat_file_filtered = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_reformat_report_msa2.txt")
#     output:
#         gene_callers_ids_reps = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids_reps.tsv"),
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     script:
#         "scripts/filter_gene_caller_ids_for_repts.py"


# rule anvi_get_sequences_for_gene_calls_reps_with_leeway:
#     """
#     Here we will extract the representative nt sequences for mapping BUT with flanking sequences
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_get_sequences_for_gene_calls_reps_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         contigsDBs = os.path.join(M.contig_dir, "{sample_name}-contigs.db"),
#         gene_callers_ids = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_gene_callers_ids_reps.tsv")
#     output:
#         fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reps_leeway.fna"),
#         external_gene_calls = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls.tsv")
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     shell:
#         """
#         anvi-get-sequences-for-gene-calls -c {input.contigsDBs} \
#                                     --gene-caller-ids {input.gene_callers_ids} \
#                                     --flank-length 150 \
#                                     --external-gene-calls {output.external_gene_calls} \
#                                     -o {output.fasta} 2> {log}
#         """


# rule rename_gene_calls_reps:
#     """Retrieve SCG taxonomy from extracted ribosomal proteins"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "rename_gene_calls_{sample_name}_{ribosomal_protein_name}.log")
#     input:
#         fna = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reps_leeway.fna"),
#         report_file = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_reformat_report_all.txt"),
#         external_gene_calls = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls.tsv")
#     output:
#         fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_reps_leeway_renamed.fna"),
#         external_gene_calls = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{sample_name}", "{sample_name}_{ribosomal_protein_name}_external_gene_calls_renamed.tsv")
#     threads: M.T('anvi_get_sequences_for_gene_calls')
#     script:
#         "scripts/rename_fasta_headers_nt.py"

# rule cat_SCG_NT_to_one_fasta_reps:
#     """DOC string
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "cat_SCG_NT_to_one_fasta_reps_{ribosomal_protein_name}.log")
#     input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{sample_names}", "{sample_names}_{ribosomal_protein_names}_reps_leeway_renamed.fna"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list)
#     output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_leeway.fna")
#     threads: M.T('cat_ribo_proteins_to_one_fasta')
#     shell:
#         "cat {input} >> {output}"


# rule add_header_SCG_NT_external_gene_calls:
#     """
#     Need to add a head to the {ribosomal_protein_name}_all_leeway_external_gene_calls.tsv
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
#     output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_leeway_external_gene_calls.tsv")
#     threads: M.T('cat_misc_data_to_one_file')
#     shell:
#         """
#         echo -e "header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n$(grep -v "header" {input})" > {output}
#         """

# rule cat_SCG_NT_external_gene_calls:
#     """
#     FIXME: double check again that the leeway sequences are the correct orientation etc
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "cat_SCG_NT_to_one_fasta_reps_{ribosomal_protein_name}.log")
#     input: expand(os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_names}", "{sample_names}", "{sample_names}_{ribosomal_protein_names}_external_gene_calls_renamed.tsv"), sample_names = M.metagenomes_names_list, ribosomal_protein_names = M.Ribosomal_protein_list)
#     output: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_leeway_external_gene_calls.tsv")
#     threads: M.T('cat_ribo_proteins_to_one_fasta')
#     shell:
#         "cat {input} >> {output}"

# rule anvi_reformat_fasta_SCG_NT:
#     """Clean up fasta headers for tree calculation."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "anvi_reformat_fasta_ribosomal_protein_file_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_reps_leeway.fna")
#     output:
#         fasta = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_reps_leeway_renamed.fna"),
#         report_file = os.path.join(dirs_dict['SCG_NT_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_all_reps_leeway_renamed_reformat_report_all.txt")
#     params:
#         prefix = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--prefix"),
#         keep_ids = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--keep-ids"),
#         exclude_ids = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--exclude-ids"),
#         simplify_names = M.get_rule_param("anvi_reformat_fasta_ribosomal_protein_file", "--simplify-names")
#     threads: M.T('anvi_reformat_fasta_ribosomal_protein_file')
#     shell:
#         "anvi-script-reformat-fasta {input} \
#                               {params.simplify_names} \
#                               --report-file {output.report_file} \
#                               -o {output.fasta} >> {log} 2>&1"



rule cat_misc_data_to_one_file:
    """
    Cat all sequence misc data from separate samples in one tsv.

    FIXME: The header is removed when concatenating all the files together. THis
    is done because otherwise the headers will be printed multiple times throughout
    the file. To avoid this I remove the header line before concatentating. In the
    next rule I add the header back to the top of the line... THis is not elegant and
    sucks.
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: expand(os.path.join(dirs_dict['EXTRACTED_RIBO_PROTEINS_TAXONOMY_DIR'], "{sample_name}", "{sample_name}_{{ribosomal_protein_name}}_estimate_scg_taxonomy_results_ed.tsv"), sample_name = M.names_list, ribosomal_protein_name = M.Ribosomal_protein_list)
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        "cat {input} >> {output}"


rule add_header_to_misc_file:
    """
    CARBON COPY IN CASE I BLOW THIS
    Adding header to misc data file.

    See rule cat_misc_data_to_one_file for why this sucks

    FIXME: replace with sed when running on linux

    # grep -v "header" {input} | sed -i '1s|^|header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n|' > {output}

    FIXME: the tmp misc_data files before *_all_misc_data_final.tsv could be removed from the final output
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
    input: rules.cat_misc_data_to_one_file.output
    output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
    threads: M.T('cat_misc_data_to_one_file')
    shell:
        """
        echo -e "new_header\tsample\tcontig_db_type\tt_domain\tt_phylum\tt_order\tt_family\tt_genus\tt_species" > {output}

        cat {input} >> {output}
        """
# rule add_header_to_misc_file:
#     """
#     Adding header to misc data file.

#     See rule cat_misc_data_to_one_file for why this sucks

#     FIXME: replace with sed when running on linux

#     # grep -v "header" {input} | sed -i '1s|^|header\tsample_name\tProject\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n|' > {output}

#     FIXME: the tmp misc_data files before *_all_misc_data_final.tsv could be removed from the final output
#     """

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "cat_ribo_proteins_to_one_fasta_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data.tsv"),
#     output: os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
#     threads: M.T('cat_misc_data_to_one_file')
#     shell:
#         """
#         echo -e "new_header\tpercent_identity\tt_domain\tt_phylum\tt_class\tt_order\tt_family\tt_genus\tt_species\n$(grep -v "header" {input})" > {output}
#         """

# rule remove_redundant_sequences_mmseqs:
#     """Remove redundant ribosomal sequences with mmseqs"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "remove_redundant_sequences_mmseqs_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_renamed.fasta")
#     output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_mmseqs_NR_rep_seq.fasta")
#     params:
#         output_prefix = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_mmseqs_NR"),
#         mmseqs_tmp = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_tmp"),
#         min_seq_id = M.get_param_value_from_config(['remove_redundant_sequences_mmseqs', '--min-seq-id'])
#     threads: M.T('remove_redundant_sequences_mmseqs')
#     shell:
#         "mmseqs easy-cluster {input} \
#                              {params.output_prefix} \
#                              {params.mmseqs_tmp} \
#                              --min-seq-id {params.min_seq_id} >> {log} 2>&1"

# Initial alignment, trim, and removal of sequences with 50% gaps or more
rule align_muscle:
    """Initial alignment with muscle"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_{ribosomal_protein_name}.log")
	input: rules.filter_for_aa_seqs.output.fasta
	output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.faa")
	threads: M.T('align_muscle')
	shell:
		"muscle -in {input} \
				-out {output} 2> {log}"


# FIXME: odseq in R will only accept a MSA object from the package MSA
# The MSA package does have muscle as an option for the alignment 
# algorithm to use but this would mean a massive MSA calculation in R
# NOT in the mood to figure our the ramifications of this at the moment
# but I have a feeling that this will really slow down the workflow.
# Now that I have the --gappyout parameter in trimal, I should be 
# doing a smarter job at trimming and subsequently removing sequences that 
# have a high percentage of gaps. 
# rule remove_outlier_seqs_odseq:
#     """Removing sequences that have > 50% gaps"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_odseq.fasta")
#     threads: M.T('remove_gaps')
#     script:
#         "scripts/odseq_remove_outliers.R --msa {input} --output"

rule trim_alignment:
    """trim alignment


    FIXME: rant on ordering of trimming and sequence removal steps, need to think about this deeper, not conclusive:

    I think that trimming twice may not be optimal. Here is my logic:
    Trimal is all about removing MSA positions (columns) that contain a threshold proportion of gaps
    i.e. trimming "horizontally". Positions with a lot of gaps are removed because they are
    phylogenetically uninformative. If we trimm before removing all sequences we might be
    making sequences seem more aligned because we have just removed gaps.

    I think trimming should be the very last step in the MSA curation.
    for example:
    (1) cluster at 100%
    (2) calculate MSA
    (3) remove sequences based on gap distribution (anvi-script-reformat-fasta)
    (4) remove positions with a lot of gaps (trimal)

    Another thing to consider is calculating a tree based on representative sequences from a
    clustered dataset. I already need to do this when I pick representative for the mapping
    steps. Why not just use that set to calculate the tree? Also, the over MSA might be
    higher quality because there is less noise with similar sequences.
    for example:
    (1) cluster at 90%
    (2) calculate MSA
    (3) remove sequences with a lot of gaps (anvi-script-reformat-fasta)
    (4) remove positions with a lot of gaps (trimal)
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_{ribosomal_protein_name}.log")
    input: rules.align_muscle.output
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed.faa")
    params:
        gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
        gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
        additional_params = M.get_param_value_from_config(['trim_alignment', 'additional_params'])
    shell:
        'trimal -in {input} \
                -out {output} \
                {params.gappyout} \
                {params.additional_params} 2> {log}'

rule remove_sequences_with_X_percent_gaps:
    """Removing sequences that have > 50% gaps"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "remove_gaps_{ribosomal_protein_name}.log")
    input: rules.trim_alignment.output
    output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
    params:
        seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_01.tsv"),
        max_percentage_gaps=M.get_param_value_from_config(['remove_sequences_with_X_percent_gaps', '--max-percentage-gaps'])
    threads: M.T('remove_gaps')
	shell:
		"anvi-script-reformat-fasta {input} \
									-o {output} \
									--max-percentage-gaps {params.max_percentage_gaps} \
									--export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# Remove sequences that have an outlier set of gaps in a sequences
# - this step further refines the MSA by removing more sequences that have too many gaps.
# to make this smarter, we will rely on the standard outlier threshold of 1.5*IQR and remove any
# sequences with more gaps than that. To accomplish this the following steps will be taken:
# * Get the distribution of gaps counts per sequences
# * calculate the outlier threshold 1.5*IQR
# * remove sequences greater than that threshold

# STEPS FOR FILTERING OUT SEQUENCING BASED ON PERCENT GAPS 
# KEEPPPPP MAY WANT TO INCLUDE LATER

# rule get_gap_count_distribution:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "get_gap_count_distribution_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
#     output: seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02.tsv")
#     params: tmp_asdf=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02_tmp"),
#             seq_counts_tsv=os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_gaps_counts_02")
#     threads: M.T('get_gap_count_distribution')
#     shell:
#         "anvi-script-reformat-fasta {input} \
#                                     -o {params.tmp_asdf} \
#                                     --export-gap-counts-table {params.seq_counts_tsv} >> {log} 2>&1"

# rule filter_out_outlier_sequences:
#     """Filter out sequences with more gaps than the 1.5*IQR of the gap distribution across all sequences"""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "filter_out_outlier_sequences_{ribosomal_protein_name}.log")
#     input:
#         tsv = rules.get_gap_count_distribution.output.seq_counts_tsv,
#         fasta = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered.fasta")
#     params:
#         gap_threshold = M.get_param_value_from_config(['MSA_gap_threshold'])
#     output: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
#     threads: M.T('filter_out_outlier_sequences')
#     script:
#         "scripts/filter_gap_count_outlier_sequence.py"

# rule align_muscle_2:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "align_muscle_2_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_seqs_filtered_final.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     threads: M.T('align_muscle_2')
#     shell:
#         "muscle -in {input} \
#                 -out {output} 2> {log}"

# rule trim_alignment_2:
#     """This rule will..."""

#     version: 1.0
#     log: os.path.join(dirs_dict['LOGS_DIR'], "trim_alignment_2_{ribosomal_protein_name}.log")
#     input: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned.fasta")
#     output: os.path.join(dirs_dict['MSA'], "MSA_2/{ribosomal_protein_name}/{ribosomal_protein_name}_trimmed.fasta")
#     params:
#         gt=M.get_param_value_from_config(['trim_alignment', '-gt']),
#         gappyout=M.get_rule_param('trim_alignment', '-gappyout'),
#         additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
#     shell:
#         'trimal -in {input} \
#                 -out {output} \
#                 {params.gappyout} \
#                 {params.additional_params} 2> {log}'

rule count_num_sequences_filtered:
    """
    This rule will count the number of Ribosomal sequences filtered at each step of the workflow.

    FIXME: for some reason and cannot prepend the file with headers and I have no idea why...
    """

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "count_num_sequences_filtered_{ribosomal_protein_name}.log")
    input:
        step1 = rules.cat_scgs_to_one_fasta_nt.output,
        step2 = rules.cluster_X_percent_sim_mmseqs.output,
        step3 = rules.remove_sequences_with_X_percent_gaps.output
    output: os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_MSA_STATS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_stats.tsv")
    threads: M.T('trim_alignment_2')
    shell:
        """
        # Headers
        echo -e  "Description\tRule_name\tNum_sequences\n > {output}"

        # How many SCGs (e.g. Ribosomal_L16) did we recruit across all input data (genomes and metagenomes)?
        step1=$(grep -c '>' {input.step1})
        echo -e "cat_scgs_to_one_fasta_nt\t$step1\n" >> {output}

        # How many SCGs do we have after we cluster them at the nt level and pick representatives?
        step2=$(grep -c '>' {input.step2})
        echo -e "cluster_X_percent_sim_mmseqs\t$step2\n" >> {output}

        # How many seqs are in the NR set?
        step3=$(grep -c '>' {input.step3})
        echo -e "remove_sequences_with_X_percent_gaps\t$step3\n" >> {output}
        """


if M.external_genomes:
    rule add_misc_layer_to_detect_if_genomic_SCG_in_cluster:
        """
        """
        version: 1.0
        input:
            misc_data = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
            final_list_of_sequences_for_tree_calculation = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
        output:
            misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
        params:
            external_genomes = M.external_genomes_names_list,
            cluster_rep_index = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_cluster.tsv")
        threads: M.T('join_renamed_fasta_with_misc_data')
        script:
            "scripts/add_layer_for_reps.py"

else:
    rule add_misc_layer_to_detect_if_genomic_SCG_in_cluster:
        """
        """
        version: 1.0
        input:
            misc_data = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_ed.tsv"),
            final_list_of_sequences_for_tree_calculation = os.path.join(dirs_dict['MSA'], "MSA_1/{ribosomal_protein_name}/{ribosomal_protein_name}_aligned_trimmed_filtered.faa")
        output:
            misc_data_final = os.path.join(dirs_dict['MISC_DATA'], "{ribosomal_protein_name}/{ribosomal_protein_name}_all_misc_data_final.tsv")
        params:
            cluster_rep_index = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_mmseqs_NR_cluster.tsv")
        threads: M.T('join_renamed_fasta_with_misc_data')
        script:
            "scripts/add_layer_for_reps_no_external_genomes.py"

rule get_headers_for_mapping:
    """
    """
    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "get_gene_caller_ids_for_mapping_{ribosomal_protein_name}.log")
    input:
        fasta = rules.remove_sequences_with_X_percent_gaps.output
    output:
        headers = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}", "{ribosomal_protein_name}_headers_for_mapping.txt")
    threads: M.T('anvi_get_sequences_for_gene_calls')
    script: "scripts/get_sequence_headers_for_mapping.py"

rule filter_for_nt_seqs_for_mapping:
    """
    """

    version: 1.0
    input:
        fasta = rules.cat_scgs_to_one_fasta_nt.output,
        headers = rules.get_headers_for_mapping.output.headers
    output:
        nt_for_mapping = os.path.join(dirs_dict['RIBOSOMAL_PROTEIN_FASTAS'], "{ribosomal_protein_name}/{ribosomal_protein_name}_scgs_for_mapping.fna")
    threads: M.T('join_renamed_fasta_with_misc_data')
    shell:
        "anvi-script-reformat-fasta {input.fasta} \
                                    -o {output} \
                                    -I {input.headers}"

rule calculate_tree:
    """Calculate a phylogenetic tree using iqtree"""

    version: 1.0
    log: os.path.join(dirs_dict['LOGS_DIR'], "calculate_tree_{ribosomal_protein_name}.log")
    input: rules.remove_sequences_with_X_percent_gaps.output
    output: os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}.iqtree")
    params:
        outfile=os.path.join(dirs_dict['TREES'], "{ribosomal_protein_name}/{ribosomal_protein_name}"),
        model = M.get_param_value_from_config(['calculate_tree', '-m']),
        additional_params = M.get_param_value_from_config(['calculate_tree', 'additional_params'])
    threads: M.T('calculate_tree')
    shell:
        "iqtree -s {input} \
                -nt AUTO \
                -m {params.model} \
                -pre {params.outfile} \
                {params.additional_params} >> {log} 2>&1"