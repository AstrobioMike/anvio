# -*- coding: utf-8

# Copyright (C) 2014, A. Murat Eren
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# Please read the COPYING file.

"""
    Here is described the annotation class. Any parser implemented in parsers.py must generate headers
    matching 'header' variable.
"""

levels_of_taxonomy = ["t_phylum", "t_class", "t_order", "t_family", "t_genus", "t_species"]
mapping_taxonomy   = [   str    ,   str    ,    str   ,    str    ,    str   ,     str    ]
db_types_taxonomy  = [  'text'  ,  'text'  ,  'text'  ,  'text'   ,  'text'  ,   'text'   ]

header    = ['prot', 'contig', 'start',  'end'   , 'direction', 'figfam', 'function']
mapping   = [ str  ,   str   ,  int   ,   int    ,     str    ,    str  ,    str    ]
db_types  = ['text',  'text' ,'numeric','numeric',    'text'  ,  'text' ,   'text'  ]

header.extend(levels_of_taxonomy)
mapping.extend(mapping_taxonomy)
db_types.extend(db_types_taxonomy)

__version__ = "0.0.1"

import os
import sys
import sqlite3
import operator
from collections import Counter

import PaPi.utils as utils
import PaPi.dictio as dictio
import PaPi.filesnpaths as filesnpaths
from PaPi.utils import ConfigError


class Annotation:
    def __init__(self, db_path):
        self.db_path = db_path
        filesnpaths.is_output_file_writable(db_path)

        self.conn = None
        self.cursor = None


    def init_database_from_matrix(self, source):
        if type(source) == type(dict()):
            self.matrix_dict = source
            self.check_keys(['prot'] + self.matrix_dict.values()[0].keys())
        if type(source) == type(str()):
            self.matrix_dict = utils.get_TAB_delimited_file_as_dictionary(source,
                                                                          column_names = header,
                                                                          column_maping = mapping)

        if os.path.exists(self.db_path):
            os.remove(self.db_path)

        self.open_db_connection()

        self.db_exec('''CREATE TABLE self (version text)''')
        self.db_exec('''INSERT INTO self VALUES(?)''', (__version__,))

        db_fields = ', '.join(['%s %s' % (t[0], t[1]) for t in zip(header, db_types)])
        self.db_exec('''CREATE TABLE annotation (%s)''' % db_fields)

        db_entries = [tuple([prot] + [self.matrix_dict[prot][h] for h in header[1:]]) for prot in self.matrix_dict]
        self.db_exec_many('''INSERT INTO annotation VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)''', db_entries)

        self.close_db_connection()


    def init_database(self):
        self.open_db_connection()

        try:
            row = self.db_exec('SELECT version from self')
        except:
            raise utils.ConfigError, "%s does not seem to be a database generated by PaPi :/" % self.db_path

        version = row.fetchall()[0][0]
        if version != __version__:
            raise utils.ConfigError, "%s was generated using version %s of the annotation db system. However,\
                                      we are at version %s. You need to re-create your database :/" % (self.db_path,
                                                                                                       version,
                                                                                                       __version__)


    def open_db_connection(self):
        self.conn = sqlite3.connect(self.db_path)
        self.cursor = self.conn.cursor()


    def commit(self):
        self.conn.commit()


    def close_db_connection(self):
        self.conn.commit()
        self.conn.close()


    def db_exec(self, sql_query, value=None):
        if value:
            return self.cursor.execute(sql_query, value)
        else:
            return self.cursor.execute(sql_query)


    def db_exec_many(self, sql_query, values):
        return self.cursor.executemany(sql_query, values)


    def init_from_dict(self, source):
        d = dictio.read_serialized_object(source)
        if 'protein' not in d.keys() or 'contigs' not in d.keys():
            raise utils.ConfigError, "'%s' does not seem to be an annotation dictionary generated by PaPi :/" % source


    def store_annotation_dict(self, output_file_path):
        dictio.write_serialized_object(self.d, output_file_path)


    def store_annotation_matrix(self, output_file_path):
        utils.store_dict_as_TAB_delimited_file(self.d['proteins'], output_file_path, header)


    def check_keys(self, keys):
        missing_keys = [key for key in header if key not in keys]
        if len(missing_keys):
            raise ConfigError, "Your input lacks one or more header fields to generate a PaPi annotation db. Here is\
                                what you are missing: %s. The complete list (and order) of headers in your TAB\
                                delimited matrix file (or dictionary) must follow this: %s." % (', '.join(missing_keys),
                                                                                                ', '.join(header))

    def get_consensus_taxonomy_for_contig(self, contig, t_level = 't_species', start = 0, stop = sys.maxint):
        """Returns (c, n, t, o) where,
            c: consensus taxonomy (the most common taxonomic call for each gene found in the contig),
            n: total number of genes found in the contig,
            t: total number of genes with known taxonomy,
            o: number of taxonomic calls that matches the consensus among t
        """

        response = self.db_exec("""SELECT %s FROM annotation WHERE contig='%s'""" % (t_level, contig, ))

        rows = response.fetchall()
        num_genes = len(rows)
        tax_str_list = [t[0] for t in rows if t[0]]
        distinct_taxa = set(tax_str_list)

        if not len(distinct_taxa):
            return None, num_genes, None

        if len(distinct_taxa) == 1:
            return distinct_taxa.pop(), num_genes, len(tax_str_list), len(tax_str_list)
        else:
            d = Counter()
            for t in tax_str_list:
                d[t] += 1
            consensus, occurrence = sorted(d.items(), key=operator.itemgetter(1))[-1]
            return consensus, num_genes, len(tax_str_list), occurrence
        sys.exit()